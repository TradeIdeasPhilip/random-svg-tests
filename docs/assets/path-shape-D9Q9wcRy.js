import{m as d}from"./misc-wGF4FraP.js";import{f as Y}from"./utility-D-kBkb6L.js";function C(a,t,n){return new DOMPoint(a,t).matrixTransform(n)}function L(a,t,n,s=.5,e=.5){const i=a.width/a.height,o=t.width/t.height;let r,c;switch(n){case"meet":case"srcRect fits completely into destRect":{i>o?(r=t.width/a.width,c=r):(c=t.height/a.height,r=c);break}case"slice":case"srcRect completely covers destRect":{i>o?(c=t.height/a.height,r=c):(r=t.width/a.width,c=r);break}default:throw new Error("wtf")}const g=-a.x*r+s*(t.width-a.width*r)+t.x,l=-a.y*c+e*(t.height-a.height*c)+t.y;return new DOMMatrix().translate(g,l).scale(r,c)}function U(){{const a={x:-1,y:-1,width:2,height:2},t={x:0,y:0,height:244,width:325},n=L(a,t,"meet");[{x:a.x,y:a.y},{x:a.x+a.width,y:a.y},{x:a.x+a.width,y:a.y+a.height},{x:a.x,y:a.y+a.height}].forEach(({x:e,y:i})=>{const o=C(e,i,n);if(o.x<t.x||o.x>t.x+t.width||o.y<t.y||o.y>t.y+t.height)throw new Error(`Test 1 failed: Point (${o.x}, ${o.y}) is outside destination (${t.x}, ${t.y}, ${t.width}, ${t.height})`)})}{const a={x:-1,y:-1,width:2,height:2},t={x:0,y:0,height:325,width:244},n=L(a,t,"meet");[{x:a.x,y:a.y},{x:a.x+a.width,y:a.y},{x:a.x+a.width,y:a.y+a.height},{x:a.x,y:a.y+a.height}].forEach(({x:e,y:i})=>{const o=C(e,i,n);if(o.x<t.x||o.x>t.x+t.width||o.y<t.y||o.y>t.y+t.height)throw new Error(`Test 2 failed: Point (${o.x}, ${o.y}) is outside destination (${t.x}, ${t.y}, ${t.width}, ${t.height})`)})}}U();class V{#n=document.createElementNS("http://www.w3.org/2000/svg","svg");#t=document.createElementNS("http://www.w3.org/2000/svg","path");constructor(){this.#n.style.width="0",this.#n.style.height="0",this.#n.style.position="absolute",this.#n.appendChild(this.#t),document.body.appendChild(this.#n)}getBBox(){return this.#t.getBBox()}get d(){return this.#t.getAttribute("d")??""}set d(t){this.#t.style.d="",this.#t.style.d=f.cssifyPath(t);const n=this.#t.style.d!="";if(this.#t.style.d="",n)this.#t.setAttribute("d",t);else throw new Error("Invalid path")}get empty(){return this.d==""}clear(){this.d=""}get length(){return this.#t.getTotalLength()}getPoint(t){return this.#t.getPointAtLength(t)}}const P=new Intl.NumberFormat("en-US",{maximumSignificantDigits:8,useGrouping:!1}).format;class M{constructor(t,n,s,e){this.x0=t,this.y0=n,this.x=s,this.y=e,d.assertFinite(t,n,s,e),this.asString=`L ${P(s)},${P(e)}`,this.outgoingAngle=this.incomingAngle=Math.atan2(e-n,s-t)}reverse(){return new M(this.x,this.y,this.x0,this.y0)}toJSON(){return{command:"L",x0:this.x0,y0:this.y0,x:this.x,y:this.y}}static relative(t,n,s,e){return new this(t,n,s+t,e+n)}incomingAngle;outgoingAngle;command="L";asString;get length(){return Math.hypot(this.x0-this.x,this.y0-this.y)}translate(t,n){return new M(this.x0+t,this.y0+n,this.x+t,this.y+n)}toCubic(){return new b(this.x0,this.y0,d.lerp(this.x0,this.x,1/3),d.lerp(this.y0,this.y,1/3),d.lerp(this.x0,this.x,2/3),d.lerp(this.y0,this.y,2/3),this.x,this.y)}transform(t){const n=C(this.x,this.y,t),s=C(this.x0,this.y0,t);return new M(s.x,s.y,n.x,n.y)}}class E{constructor(t,n,s,e,i,o,r){this.x0=t,this.y0=n,this.x1=s,this.y1=e,this.x=i,this.y=o,this.creationInfo=r,d.assertFinite(t,n,s,e,i,o),this.asString=`Q ${P(s)},${P(e)} ${P(i)},${P(o)}`}reverse(){return E.controlPoints(this.x,this.y,this.x1,this.y1,this.x0,this.y0)}static line(t,n,s,e,i){return new this(t,n,(t+s)/2,(n+e)/2,s,e,i)}static line4(t,n,s,e){return this.line(t,n,s,e,{source:"line"})}static line2(t,n){return this.line4(t.x,t.y,n.x,n.y)}static angles(t,n,s,e,i,o){d.assertFinite(t,n,s,e,i,o);const r=it({x0:t,y0:n,angle:s},{x0:e,y0:i,angle:o+Math.PI});return r?new this(t,n,r.x,r.y,e,i,{source:"angles",success:!0,angle:o,angle0:s}):this.line(t,n,e,i,{source:"angles",success:!1,angle:o,angle0:s})}newAngles(t,n){return t??=this.requestedIncomingAngle,n??=this.requestedOutgoingAngle,E.angles(this.x0,this.y0,t,this.x,this.y,n)}toJSON(){return{command:"Q",x0:this.x0,y0:this.y0,x1:this.x1,y1:this.y1,x:this.x,y:this.y,creationInfo:this.creationInfo}}static controlPoints(t,n,s,e,i,o){return new this(t,n,s,e,i,o,{source:"controlPoints"})}static relative(t,n,s,e,i,o){return this.controlPoints(t,n,s+t,e+n,i+t,o+n)}get incomingAngle(){return Math.atan2(this.y1-this.y0,this.x1-this.x0)}get outgoingAngle(){return Math.atan2(this.y-this.y1,this.x-this.x1)}get requestedIncomingAngle(){return this.creationInfo.source=="angles"?this.creationInfo.angle0:this.incomingAngle}get requestedOutgoingAngle(){return this.creationInfo.source=="angles"?this.creationInfo.angle:this.outgoingAngle}command="Q";asString;translate(t,n){return E.controlPoints(this.x0+t,this.y0+n,this.x1+t,this.y1+n,this.x+t,this.y+n)}transform(t){const n=C(this.x0,this.y0,t),s=C(this.x1,this.y1,t),e=C(this.x,this.y,t);return E.controlPoints(n.x,n.y,s.x,s.y,e.x,e.y)}toCubic(){return new b(this.x0,this.y0,d.lerp(this.x0,this.x1,2/3),d.lerp(this.y0,this.y1,2/3),d.lerp(this.x,this.x1,2/3),d.lerp(this.y,this.y1,2/3),this.x,this.y)}split(t){const{x:n,x0:s,x1:e,y:i,y0:o,y1:r}=this,c=s,g=o,l=(1-t)*s+t*e,u=(1-t)*o+t*r,h=(1-t)**2*s+2*(1-t)*t*e+t**2*n,m=(1-t)**2*o+2*(1-t)*t*r+t**2*i,p=E.controlPoints(c,g,l,u,h,m),y=h,v=m,A=(1-t)*e+t*n,$=(1-t)*r+t*i,T=n,I=i,X=E.controlPoints(y,v,A,$,T,I);return[p,X]}multiSplit(t){if(d.assertFinite(t),t<1||(t|0)!=t)throw new Error("wtf");const n=[];let s=this;for(;t>1;){const e=1/t;let i;[i,s]=s.split(e),n.push(i),t--}return n.push(s),n}}class b{constructor(t,n,s,e,i,o,r,c){this.x0=t,this.y0=n,this.x1=s,this.y1=e,this.x2=i,this.y2=o,this.x=r,this.y=c,d.assertFinite(t,n,s,e,i,o,r,c),this.asString=`C ${P(s)},${P(e)} ${P(i)},${P(o)} ${P(r)},${P(c)}`}reverse(){return new b(this.x,this.y,this.x2,this.y2,this.x1,this.y1,this.x0,this.y0)}static relative(t,n,s,e,i,o,r,c){return new this(t,n,s+t,e+n,i+t,o+n,r+t,c+n)}get incomingAngle(){return Math.atan2(this.y1-this.y0,this.x1-this.x0)}get outgoingAngle(){return Math.atan2(this.y-this.y2,this.x-this.x2)}command="C";asString;translate(t,n){return new b(this.x0+t,this.y0+n,this.x1+t,this.y1+n,this.x2+t,this.y2+n,this.x+t,this.y+n)}transform(t){const n=C(this.x0,this.y0,t),s=C(this.x1,this.y1,t),e=C(this.x2,this.y2,t),i=C(this.x,this.y,t);return new b(n.x,n.y,s.x,s.y,e.x,e.y,i.x,i.y)}toCubic(){return this}}class R{get commands(){return this.#n}addCommand(t){this.#n.push(t),this.#t=void 0}addCommands(t){return t.forEach(n=>this.addCommand(n)),this}static fromStrings(t){let n=t.join(" ");const s=[];let e;for(;n=n.replace(/^ */,""),n!="";){let i=Q.exec(n);if(i){const o=d.parseFloatX(i[1]),r=d.parseFloatX(i[2]);if(o===void 0||r===void 0)throw console.error(i,o,r,this),new Error("wtf");e&&s.push(e),e=this.M(o,r),n=i[3];continue}if(e){if(i=S.exec(n),i){const o=d.parseFloatX(i[1]),r=d.parseFloatX(i[2]);if(o===void 0||r===void 0)throw console.error(i,o,r,this),new Error("wtf");e=e.L(o,r),n=i[3];continue}if(i=B.exec(n),i){const o=d.parseFloatX(i[1]),r=d.parseFloatX(i[2]),c=d.parseFloatX(i[3]),g=d.parseFloatX(i[4]);if(o===void 0||r===void 0||c===void 0||g===void 0)throw console.error(i,o,r,c,g,this),new Error("wtf");e=e.Q(o,r,c,g),n=i[5];continue}if(i=J.exec(n),i){const o=d.parseFloatX(i[1]),r=d.parseFloatX(i[2]),c=d.parseFloatX(i[3]),g=d.parseFloatX(i[4]),l=d.parseFloatX(i[5]),u=d.parseFloatX(i[6]);if(o===void 0||r===void 0||c===void 0||g===void 0||l===void 0||u===void 0)throw console.error(i,o,r,c,g,l,u,this),new Error("wtf");e=e.C(o,r,c,g,l,u),n=i[7];continue}}throw console.error(n),new Error("wtf")}return e&&s.push(e),s}static M(t,n){const s=new R;return s.M(t,n),s}#n=[];get pathShape(){return new f(this.#n)}#t;M(t,n,s=NaN){return d.assertFinite(t,n),this.#t={x:t,y:n,outgoingAngle:s},this}previous(){return this.#t??this.#n.at(-1)}H(t){const n=this.previous();return this.addCommand(new M(n.x,n.y,t,n.y)),this}V(t){const n=this.previous();return this.addCommand(new M(n.x,n.y,n.x,t)),this}L(t,n){const s=this.previous();return this.addCommand(new M(s.x,s.y,t,n)),this}Q(t,n,s,e){const i=this.previous();return this.addCommand(E.controlPoints(i.x,i.y,t,n,s,e)),this}Q_HV(t,n){const s=this.previous();return this.Q(t,s.y,t,n)}Q_VH(t,n){const s=this.previous();return this.Q(s.x,n,t,n)}Q_angles(t,n,s,e){const i=this.previous();if(e??=i.outgoingAngle,e===void 0)throw new Error("wtf");return this.addCommand(E.angles(i.x,i.y,e,t,n,s)),this}C(t,n,s,e,i,o){const r=this.previous();return this.addCommand(new b(r.x,r.y,t,n,s,e,i,o)),this}circle(t,n,s="cw"){const e=this.previous(),i=e.x,o=e.y,r=Math.atan2(o-n,i-t),c=Math.hypot(o-n,i-t),g=s=="cw"?1:-1,l=r+Math.PI*2*g,u=d.makeLinear(0,r,1,l);function h(y){switch(y){case 0:case 1:return e;default:{const v=u(y),A=d.polarToRectangular(c,v);return{x:t+A.x,y:n+A.y}}}}function m(y){return h(y)}return this.addParametricPath(m,8),this}arc(t,n,s,e,i){const o=this.previous(),r=o.x,c=o.y;let g=d.positiveModulo(Math.atan2(c-n,r-t),Math.PI*2);const l=Math.hypot(c-n,r-t);let u=d.positiveModulo(Math.atan2(e-n,s-t),Math.PI*2);const h=Math.hypot(e-n,s-t);i=="cw"?g>u&&(u+=Math.PI*2):g<u&&(g+=Math.PI*2);const m=Math.abs(g-u),p=Math.ceil(m*1.17+1e-4),y=d.makeLinear(0,l,1,h),v=d.makeLinear(0,g,1,u);function A($){switch($){case 0:return o;case 1:return{x:s,y:e};default:{const T=d.polarToRectangular(y($),v($));return{x:t+T.x,y:n+T.y}}}}return this.addParametricPath(A,p)}addParametricPath(t,n){if(n<=0)throw new Error("wtf");const s=.01/n,e=d.initializedArray(n+1,i=>{const o=i/n,r=t(o),c=j(t,o,s);return{t:o,point:r,direction:c}});if(e.some(i=>!isFinite(i.direction))){const{x:i,y:o}=e[0].point;if(d.assertFinite(i,o),e.some(r=>r.point.x!=i||r.point.y!=o))throw new Error("Unable to create a path from this function.  Unable to compute the derivative.");for(let r=0;r<n;r++)this.Q(i,o,i,o)}else d.initializedArray(n,o=>({from:e[o],to:e[o+1]})).forEach(o=>{this.Q_angles(o.to.point.x,o.to.point.y,o.to.direction,o.from.direction)});return this}}function O(a,t,n){if(!(t>=0&&t<=1))throw new Error("Expected 0 ≤ t ≤ 1");const s=Math.max(0,t-n),e=a(s),i=Math.min(1,t+n),o=a(i),r=o.x-e.x,c=o.y-e.y;return r==0&&c==0?NaN:Math.atan2(c,r)}function j(a,t,n){const s=O(a,t,n*2),e=O(a,t,n*1),i=s-e;return e-i}const F=" *",x="(-?[0-9]+\\.?[0-9]*(?:[eE][-+]?[0-9]+)?)",w="(?: *[, ] *|(?=-))",Q=new RegExp(`^M${F}${x}${w}${x}(.*)$`),z=new RegExp(`^m${F}${x}${w}${x}(.*)$`),S=new RegExp(`^L${F}${x}${w}${x}(.*)$`),k=new RegExp(`^${w}${x}${w}${x}(.*)$`),G=new RegExp(`^l${F}${x}${w}${x}(.*)$`),H=new RegExp(`^H${F}${x}(.*)$`),Z=new RegExp(`^h${F}${x}(.*)$`),K=new RegExp(`^V${F}${x}(.*)$`),W=new RegExp(`^v${F}${x}(.*)$`),q=new RegExp(`^${w}${x}(.*)$`),_=q,B=new RegExp(`^Q${F}${x}${w}${x}${w}${x}${w}${x}(.*)$`),tt=new RegExp(`^${w}${x}${w}${x}${w}${x}${w}${x}(.*)$`),nt=new RegExp(`^q${F}${x}${w}${x}${w}${x}${w}${x}(.*)$`),J=new RegExp(`^C${F}${x}${w}${x}${w}${x}${w}${x}${w}${x}${w}${x}(.*)$`),D=new RegExp(`^${w}${x}${w}${x}${w}${x}${w}${x}${w}${x}${w}${x}(.*)$`),et=new RegExp(`^c${F}${x}${w}${x}${w}${x}${w}${x}${w}${x}${w}${x}(.*)$`),st=new RegExp("^[zZ](.*)$");class ot extends Error{constructor(t,n){super(t),this.where=n}}class f{reverse(){return new f(this.commands.toReversed().map(t=>t.reverse()))}static fromString(t){const n=this.fromJson(t);if(n)return n;let s=t,e=null;const i=h=>new ot(h,s),o=h=>{const m=d.parseFloatX(h);if(m===void 0)throw i(`Invalid number: "${h}"`);return m};let r=0,c=0;const g=[],l=h=>{g.push(h),r=h.x,c=h.y};let u;for(;s=s.replace(/^ */,""),s!="";){if(e=Q.exec(s)){r=o(e[1]),c=o(e[2]),u={x0:r,y0:c},s=e[3];continue}if(e=z.exec(s)){for(r+=o(e[1]),c+=o(e[2]),u={x0:r,y0:c},s=e[3];e=k.exec(s);){const h=M.relative(r,c,o(e[1]),o(e[2]));l(h),s=e[3]}continue}if(!u)throw i("Must start with an M command.");if(e=st.exec(s)){if(r!=u.x0||c!=u.y0){const h=new M(r,c,u.x0,u.y0);l(h)}s=e[1];continue}if(e=S.exec(s)){const h=o(e[1]),m=o(e[2]),p=new M(r,c,h,m);l(p),s=e[3];continue}if(e=G.exec(s)){for(;e;){const h=o(e[1]),m=o(e[2]),p=M.relative(r,c,h,m);l(p),s=e[3],e=k.exec(s)}continue}if(e=H.exec(s)){const h=o(e[1]),m=new M(r,c,h,c);l(m),s=e[2];continue}if(e=Z.exec(s)){for(;e;){const h=o(e[1]),m=new M(r,c,r+h,c);l(m),s=e[2],e=_.exec(s)}continue}if(e=K.exec(s)){const h=o(e[1]),m=new M(r,c,r,h);l(m),s=e[2];continue}if(e=W.exec(s)){for(;e;){const h=o(e[1]),m=new M(r,c,r,c+h);l(m),s=e[2],e=q.exec(s)}continue}if(e=B.exec(s)){const h=o(e[1]),m=o(e[2]),p=o(e[3]),y=o(e[4]),v=E.controlPoints(r,c,h,m,p,y);l(v),s=e[5];continue}if(e=nt.exec(s)){for(;e;){const h=o(e[1]),m=o(e[2]),p=o(e[3]),y=o(e[4]),v=E.relative(r,c,h,m,p,y);l(v),s=e[5],e=tt.exec(s)}continue}if(e=J.exec(s)){for(;e;){const h=o(e[1]),m=o(e[2]),p=o(e[3]),y=o(e[4]),v=o(e[5]),A=o(e[6]),$=new b(r,c,h,m,p,y,v,A);l($),s=e[7],e=D.exec(s)}continue}if(e=et.exec(s)){for(;e;){const h=o(e[1]),m=o(e[2]),p=o(e[3]),y=o(e[4]),v=o(e[5]),A=o(e[6]),$=b.relative(r,c,h,m,p,y,v,A);l($),s=e[7],e=D.exec(s)}continue}throw i("Confused.")}return new this(g)}static fromJson(t){try{const s=JSON.parse(t).commands.map(e=>{switch(e.command){case"C":{const{x0:i,y0:o,x1:r,y1:c,x2:g,y2:l,x:u,y:h}=e;return new b(i,o,r,c,g,l,u,h)}case"L":{const{x0:i,y0:o,x:r,y:c}=e;return new M(i,o,r,c)}case"Q":{const{x0:i,y0:o,x:r,y:c,creationInfo:g}=e;switch(g.source){case"angles":{const{angle0:l,angle:u}=g,h=E.angles(i,o,l,r,c,u);return(h.creationInfo.source!="angles"||h.creationInfo.success!=g.success)&&console.warn("different",e,h),h}case"controlPoints":{const{x1:l,y1:u}=e;return E.controlPoints(i,o,l,u,r,c)}case"line":return E.line4(i,o,r,c);default:throw new Error(`Unknown source: "${g.source}"`)}}default:throw new Error(`Unknown command: "${e.command}"`)}});return new f(s)}catch{return}}matchForMorph(t){const n=this.commands.map(r=>r.toCubic()),s=t.commands.map(r=>r.toCubic());if(n.length!=s.length){const{shorter:r,longer:c}=n.length<s.length?{shorter:n,longer:s}:{shorter:s,longer:n};if(r.length==0)throw new Error("can't morph something into nothing");const g=c.length/r.length,l=[];r.forEach((u,h)=>{const m=Math.round((h+1)*g);for(;l.length<m;)l.push(u)}),r.length=0,r.push(...l)}if(n.length!=s.length)throw new Error("wtf");function e(r){return f.cssifyPath(r.map(c=>new f([c]).rawPath).join())}const i=e(n),o=e(s);return[i,o]}commands;get endX(){return this.commands.at(-1)?.x}get endY(){return this.commands.at(-1)?.y}get startX(){return this.commands.at(0)?.x0}get startY(){return this.commands.at(0)?.y0}constructor(t){this.commands=[...t]}static cssifyPath(t){return`path('${t}')`}get cssPath(){return f.cssifyPath(this.rawPath)}makeElement(){const t=document.createElementNS("http://www.w3.org/2000/svg","path"),n=this.cssPath;if(t.style.d=n,t.style.d=="")throw console.error(n,t),new Error("wtf");return t}static needAnM(t,n){return n?!t||t.x!=n.x0||t.y!=n.y0:!1}get rawPath(){return this.splitOnMove().flatMap(t=>{const n=[`M ${P(t.startX)},${P(t.startY)}`];return t.commands.forEach(s=>n.push(s.asString)),t.startX==t.endX&&t.startY==t.endY&&n.push("Z"),n}).join(" ")}get cssPaths(){return this.splitOnMove().map(t=>t.cssPath)}get rawPaths(){return this.splitOnMove().map(t=>t.rawPath)}splitOnMove(){const t=[];let n=[];return this.commands.forEach(s=>{f.needAnM(n.at(-1),s)&&(n=[],t.push(n)),n.push(s)}),t.map(s=>new f(s))}static join(t){return new f(t.flatMap(({Δx:n,Δy:s,shape:e})=>e.translate(n,s).commands))}convertToCubics(){return new f(this.commands.map(t=>t.toCubic()))}translate(t,n){return new f(this.commands.map(s=>s.translate(t,n)))}transform(t){return new f(this.commands.map(n=>n.transform(t)))}static parametric(t,n){const s=t(0);return R.M(s.x,s.y).addParametricPath(t,n).pathShape}static glitchFreeParametric(t,n){const s=this.#t(t,n,0);return Y(s)}static#n=new V;static#t(t,n,s){if(s>0&&console.log(s),s>=4){console.log("⚝");return}const i=this.parametric(t,n).commands.map((c,g,l)=>{const u=g/l.length,h=(g+1)/l.length;return{command:c,initialT:u,finalT:h}});let o=0;const r=c=>{const g=new this([c]);this.#n.d=g.rawPath;const l=this.#n.length,u=Math.hypot(c.x0-c.x,c.y0-c.y),h=l/u;return h<2||!isFinite(h)};for(;o<i.length;){const c=i[o].command;if(r(c))o++;else{const g=Math.max(0,o-1);let l=o+1;for(;l<i.length;){const $=i[l].command;if(l++,r($))break}const u=i[g].initialT,h=i[l-1].finalT,m=d.makeLinear(0,u,1,h),p=$=>t(m($)),y=l-g,v=y+1,A=this.#t(p,v,s+1);if(A===void 0){if(s>0)return;const $=i[o],{x0:T,y0:I,x:X,y:N}=$.command;$.command=E.line4(T,I,X,N),o++}else i.splice(g,y,...A.commands.map(($,T,I)=>{const X=m(T/I.length),N=m((T+1)/I.length);return{command:$,initialT:X,finalT:N}})),o+=v}}return new f(i.map(c=>c.command))}static fixAngleRounding(t){return t+400-400}static toDegrees(t){return Math.round(t*d.degreesPerRadian*100)/100}dump(){const t=this.commands.map((n,s)=>{const{x0:e,y0:i,x:o,y:r,incomingAngle:c,outgoingAngle:g,command:l}=n,u=document.createElementNS("http://www.w3.org/2000/svg","path");u.setAttribute("d",new f([n]).rawPath);const h=u.getTotalLength(),m=this.commands[s-1],y=f.needAnM(m,n)?{}:{difference:f.toDegrees(d.angleBetween(m.outgoingAngle,c))};return{x0:e,y0:i,x:o,y:r,incomingAngle:f.toDegrees(c),outgoingAngle:f.toDegrees(g),length:h,c:l,...y}});console.table(t),console.log(this.rawPath),console.log(JSON.stringify(this))}}function it(a,t){if(d.assertFinite(a.x0,a.y0,a.angle,t.x0,t.y0,t.angle),isNaN(a.angle)||isNaN(t.angle)||a.angle==t.angle)return;const n=Math.tan(a.angle),s=Math.tan(t.angle),e=Math.abs(n)*100>Number.MAX_SAFE_INTEGER,i=Math.abs(s)*100>Number.MAX_SAFE_INTEGER;if(e&&i)return;const o=Math.atan2(t.y0-a.y0,t.x0-a.x0),r=d.angleBetween(a.angle,o),c=d.angleBetween(t.angle,o);if(r==0||Math.abs(c)==Math.PI){if(Math.abs(r)==Math.PI||c==0)return;const u=(a.x0+t.x0)/2,h=(a.y0+t.y0)/2;return{x:u,y:h}}const g=Math.sign(r),l=Math.sign(c);if(!(g!=l||g==0)&&!(Math.abs(c)<=Math.abs(r)+d.radiansPerDegree))if(e||i){const u=e?a.x0:t.x0,h=e?{...t,slope:s}:{...a,slope:n},m=h.slope*(u-h.x0)+h.y0;return{x:u,y:m}}else{const u=(t.y0-s*t.x0-a.y0+n*a.x0)/(n-s),h=n*(u-a.x0)+a.y0;return{x:u,y:h}}}export{M as L,f as P,E as Q,ot as a,R as b,V as c,L as p};
