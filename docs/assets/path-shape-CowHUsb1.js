import{m as h}from"./misc-CLGTS8fC.js";const v=new Intl.NumberFormat("en-US",{maximumSignificantDigits:8}).format;class M{constructor(t,n,e,s){this.x0=t,this.y0=n,this.x=e,this.y=s,h.assertFinite(t,n,e,s),this.asString=`L ${v(e)},${v(s)}`,this.outgoingAngle=this.incomingAngle=Math.atan2(s-n,e-t)}toJSON(){return{command:"L",x0:this.x0,y0:this.y0,x:this.x,y:this.y}}static relative(t,n,e,s){return new this(t,n,e+t,s+n)}incomingAngle;outgoingAngle;command="L";asString;translate(t,n){return new M(this.x0+t,this.y0+n,this.x+t,this.y+n)}toCubic(){return new F(this.x0,this.y0,h.lerp(this.x0,this.x,1/3),h.lerp(this.y0,this.y,1/3),h.lerp(this.x0,this.x,2/3),h.lerp(this.y0,this.y,2/3),this.x,this.y)}}class E{constructor(t,n,e,s,r,o,i){this.x0=t,this.y0=n,this.x1=e,this.y1=s,this.x=r,this.y=o,this.creationInfo=i,h.assertFinite(t,n,e,s,r,o),this.asString=`Q ${v(e)},${v(s)} ${v(r)},${v(o)}`}static line(t,n,e,s,r){return new this(t,n,(t+e)/2,(n+s)/2,e,s,r)}static line4(t,n,e,s){return this.line(t,n,e,s,{source:"line"})}static line2(t,n){return this.line4(t.x,t.y,n.x,n.y)}static angles(t,n,e,s,r,o){h.assertFinite(t,n,e,s,r,o);const i=G({x0:t,y0:n,angle:e},{x0:s,y0:r,angle:o+Math.PI});return i?new this(t,n,i.x,i.y,s,r,{source:"angles",success:!0,angle:o,angle0:e}):this.line(t,n,s,r,{source:"angles",success:!1,angle:o,angle0:e})}newAngles(t,n){return t??=this.requestedIncomingAngle,n??=this.requestedOutgoingAngle,E.angles(this.x0,this.y0,t,this.x,this.y,n)}toJSON(){return{command:"Q",x0:this.x0,y0:this.y0,x1:this.x1,y1:this.y1,x:this.x,y:this.y,creationInfo:this.creationInfo}}static controlPoints(t,n,e,s,r,o){return new this(t,n,e,s,r,o,{source:"controlPoints"})}static relative(t,n,e,s,r,o){return this.controlPoints(t,n,e+t,s+n,r+t,o+n)}get incomingAngle(){return Math.atan2(this.y1-this.y0,this.x1-this.x0)}get outgoingAngle(){return Math.atan2(this.y-this.y1,this.x-this.x1)}get requestedIncomingAngle(){return this.creationInfo.source=="angles"?this.creationInfo.angle0:this.incomingAngle}get requestedOutgoingAngle(){return this.creationInfo.source=="angles"?this.creationInfo.angle:this.outgoingAngle}command="Q";asString;translate(t,n){return E.controlPoints(this.x0+t,this.y0+n,this.x1+t,this.y1+n,this.x+t,this.y+n)}toCubic(){return new F(this.x0,this.y0,h.lerp(this.x0,this.x1,2/3),h.lerp(this.y0,this.y1,2/3),h.lerp(this.x,this.x1,2/3),h.lerp(this.y,this.y1,2/3),this.x,this.y)}split(t){const{x:n,x0:e,x1:s,y:r,y0:o,y1:i}=this,c=e,d=o,g=(1-t)*e+t*s,l=(1-t)*o+t*i,a=(1-t)**2*e+2*(1-t)*t*s+t**2*n,m=(1-t)**2*o+2*(1-t)*t*i+t**2*r,p=E.controlPoints(c,d,g,l,a,m),w=a,y=m,A=(1-t)*s+t*n,P=(1-t)*i+t*r,R=n,T=r,k=E.controlPoints(w,y,A,P,R,T);return[p,k]}multiSplit(t){if(h.assertFinite(t),t<1||(t|0)!=t)throw new Error("wtf");const n=[];let e=this;for(;t>1;){const s=1/t;let r;[r,e]=e.split(s),n.push(r),t--}return n.push(e),n}}class F{constructor(t,n,e,s,r,o,i,c){this.x0=t,this.y0=n,this.x1=e,this.y1=s,this.x2=r,this.y2=o,this.x=i,this.y=c,h.assertFinite(t,n,e,s,r,o,i,c),this.asString=`C ${v(e)},${v(s)} ${v(r)},${v(o)} ${v(i)},${v(c)}`}reverse(){return new F(this.x,this.y,this.x2,this.y2,this.x1,this.y1,this.x0,this.y0)}static relative(t,n,e,s,r,o,i,c){return new this(t,n,e+t,s+n,r+t,o+n,i+t,c+n)}get incomingAngle(){return Math.atan2(this.y1-this.y0,this.x1-this.x0)}get outgoingAngle(){return Math.atan2(this.y-this.y2,this.x-this.x2)}command="C";asString;translate(t,n){return new F(this.x0+t,this.y0+n,this.x1+t,this.y1+n,this.x2+t,this.y2+n,this.x+t,this.y+n)}toCubic(){return this}}class N{get commands(){return this.#t}addCommand(t){this.#t.push(t),this.#n=void 0}addCommands(t){return t.forEach(n=>this.addCommand(n)),this}static fromStrings(t){let n=t.join(" ");const e=[];let s;for(;n=n.replace(/^ */,""),n!="";){let r=L.exec(n);if(r){const o=h.parseFloatX(r[1]),i=h.parseFloatX(r[2]);if(o===void 0||i===void 0)throw console.error(r,o,i,this),new Error("wtf");s&&e.push(s),s=this.M(o,i),n=r[3];continue}if(s){if(r=O.exec(n),r){const o=h.parseFloatX(r[1]),i=h.parseFloatX(r[2]);if(o===void 0||i===void 0)throw console.error(r,o,i,this),new Error("wtf");s=s.L(o,i),n=r[3];continue}if(r=Q.exec(n),r){const o=h.parseFloatX(r[1]),i=h.parseFloatX(r[2]),c=h.parseFloatX(r[3]),d=h.parseFloatX(r[4]);if(o===void 0||i===void 0||c===void 0||d===void 0)throw console.error(r,o,i,c,d,this),new Error("wtf");s=s.Q(o,i,c,d),n=r[5];continue}if(r=S.exec(n),r){const o=h.parseFloatX(r[1]),i=h.parseFloatX(r[2]),c=h.parseFloatX(r[3]),d=h.parseFloatX(r[4]),g=h.parseFloatX(r[5]),l=h.parseFloatX(r[6]);if(o===void 0||i===void 0||c===void 0||d===void 0||g===void 0||l===void 0)throw console.error(r,o,i,c,d,g,l,this),new Error("wtf");s=s.C(o,i,c,d,g,l),n=r[7];continue}}throw console.error(n),new Error("wtf")}return s&&e.push(s),e}static M(t,n){const e=new N;return e.M(t,n),e}#t=[];get pathShape(){return new $(this.#t)}#n;M(t,n,e=NaN){return h.assertFinite(t,n),this.#n={x:t,y:n,outgoingAngle:e},this}previous(){return this.#n??this.#t.at(-1)}H(t){const n=this.previous();return this.addCommand(new M(n.x,n.y,t,n.y)),this}V(t){const n=this.previous();return this.addCommand(new M(n.x,n.y,n.x,t)),this}L(t,n){const e=this.previous();return this.addCommand(new M(e.x,e.y,t,n)),this}Q(t,n,e,s){const r=this.previous();return this.addCommand(E.controlPoints(r.x,r.y,t,n,e,s)),this}Q_HV(t,n){const e=this.previous();return this.Q(t,e.y,t,n)}Q_VH(t,n){const e=this.previous();return this.Q(e.x,n,t,n)}Q_angles(t,n,e,s){const r=this.previous();if(s??=r.outgoingAngle,s===void 0)throw new Error("wtf");return this.addCommand(E.angles(r.x,r.y,s,t,n,e)),this}C(t,n,e,s,r,o){const i=this.previous();return this.addCommand(new F(i.x,i.y,t,n,e,s,r,o)),this}circle(t,n,e="cw"){const s=this.previous(),r=s.x,o=s.y,i=Math.atan2(o-n,r-t),c=Math.hypot(o-n,r-t),d=e=="cw"?1:-1,g=i+Math.PI*2*d,l=h.makeLinear(0,i,1,g);function a(w){switch(w){case 0:case 1:return s;default:{const y=l(w),A=h.polarToRectangular(c,y);return{x:t+A.x,y:n+A.y}}}}function m(w){return a(w)}return this.addParametricPath(m,8),this}arc(t,n,e,s,r){const o=this.previous(),i=o.x,c=o.y;let d=h.positiveModulo(Math.atan2(c-n,i-t),Math.PI*2);const g=Math.hypot(c-n,i-t);let l=h.positiveModulo(Math.atan2(s-n,e-t),Math.PI*2);const a=Math.hypot(s-n,e-t);r=="cw"?d>l&&(l+=Math.PI*2):d<l&&(d+=Math.PI*2);const m=Math.abs(d-l),p=Math.ceil(m*1.17+1e-4),w=h.makeLinear(0,g,1,a),y=h.makeLinear(0,d,1,l);function A(P){switch(P){case 0:return o;case 1:return{x:e,y:s};default:{const R=h.polarToRectangular(w(P),y(P));return{x:t+R.x,y:n+R.y}}}}return this.addParametricPath(A,p)}addParametricPath(t,n){if(n<=0)throw new Error("wtf");const e=.01/n,s=h.initializedArray(n+1,o=>{const i=o/n,c=t(i),d=D(t,i,e);return{t:i,point:c,direction:d}});return h.initializedArray(n,o=>({from:s[o],to:s[o+1]})).forEach(o=>{this.Q_angles(o.to.point.x,o.to.point.y,o.to.direction,o.from.direction)}),this}}function I(x,t,n){if(!(t>=0&&t<=1))throw new Error("Expected 0 ≤ t ≤ 1");const e=Math.max(0,t-n),s=x(e),r=Math.min(1,t+n),o=x(r),i=o.x-s.x,c=o.y-s.y;return i==0&&c==0?NaN:Math.atan2(c,i)}function D(x,t,n){const e=I(x,t,n*2),s=I(x,t,n*1),r=e-s;return s-r}const C=" *",u="(-?[0-9]+\\.?[0-9]*(?:[eE][-+]?[0-9]+)?)",f="(?: *[, ] *|(?=-))",L=new RegExp(`^M${C}${u}${f}${u}(.*)$`),q=new RegExp(`^m${C}${u}${f}${u}(.*)$`),O=new RegExp(`^L${C}${u}${f}${u}(.*)$`),b=new RegExp(`^${f}${u}${f}${u}(.*)$`),J=new RegExp(`^l${C}${u}${f}${u}(.*)$`),V=new RegExp(`^h${C}${u}(.*)$`),Y=new RegExp(`^v${C}${u}(.*)$`),Q=new RegExp(`^Q${C}${u}${f}${u}${f}${u}${f}${u}(.*)$`),j=new RegExp(`^${f}${u}${f}${u}${f}${u}${f}${u}(.*)$`),z=new RegExp(`^q${C}${u}${f}${u}${f}${u}${f}${u}(.*)$`),S=new RegExp(`^C${C}${u}${f}${u}${f}${u}${f}${u}${f}${u}${f}${u}(.*)$`),X=new RegExp(`^${f}${u}${f}${u}${f}${u}${f}${u}${f}${u}${f}${u}(.*)$`),B=new RegExp(`^c${C}${u}${f}${u}${f}${u}${f}${u}${f}${u}${f}${u}(.*)$`),H=new RegExp("^[zZ](.*)$");class U extends Error{constructor(t,n){super(t),this.where=n}}class ${static fromString(t){const n=this.fromJson(t);if(n)return n;let e=t,s=null;const r=a=>new U(a,e),o=a=>{const m=h.parseFloatX(a);if(m===void 0)throw r(`Invalid number: "${a}"`);return m};let i=0,c=0;const d=[],g=a=>{d.push(a),i=a.x,c=a.y};let l;for(;e=e.replace(/^ */,""),e!="";){if(s=L.exec(e)){i=o(s[1]),c=o(s[2]),l={x0:i,y0:c},e=s[3];continue}if(s=q.exec(e)){for(i+=o(s[1]),c+=o(s[2]),l={x0:i,y0:c},e=s[3];s=b.exec(e);){const a=M.relative(i,c,o(s[1]),o(s[2]));g(a),e=s[3]}continue}if(!l)throw r("Must start with an M command.");if(s=H.exec(e)){if(i!=l.x0||c!=l.y0){const a=new M(i,c,l.x0,l.y0);g(a)}e=s[1];continue}if(s=O.exec(e)){const a=o(s[1]),m=o(s[2]),p=new M(i,c,a,m);g(p),e=s[3];continue}if(s=J.exec(e)){for(;s;){const a=o(s[1]),m=o(s[2]),p=M.relative(i,c,a,m);g(p),e=s[3],s=b.exec(e)}continue}if(s=V.exec(e)){const a=o(s[1]),m=new M(i,c,i+a,c);g(m),e=s[2];continue}if(s=Y.exec(e)){const a=o(s[1]),m=new M(i,c,i,c+a);g(m),e=s[2];continue}if(s=Q.exec(e)){const a=o(s[1]),m=o(s[2]),p=o(s[3]),w=o(s[4]),y=E.controlPoints(i,c,a,m,p,w);g(y),e=s[5];continue}if(s=z.exec(e)){for(;s;){const a=o(s[1]),m=o(s[2]),p=o(s[3]),w=o(s[4]),y=E.relative(i,c,a,m,p,w);g(y),e=s[5],s=j.exec(e)}continue}if(s=S.exec(e)){for(;s;){const a=o(s[1]),m=o(s[2]),p=o(s[3]),w=o(s[4]),y=o(s[5]),A=o(s[6]),P=new F(i,c,a,m,p,w,y,A);g(P),e=s[7],s=X.exec(e)}continue}if(s=B.exec(e)){for(;s;){const a=o(s[1]),m=o(s[2]),p=o(s[3]),w=o(s[4]),y=o(s[5]),A=o(s[6]),P=F.relative(i,c,a,m,p,w,y,A);g(P),e=s[7],s=X.exec(e)}continue}throw r("Confused.")}return new this(d)}static fromJson(t){try{const e=JSON.parse(t).commands.map(s=>{switch(s.command){case"C":{const{x0:r,y0:o,x1:i,y1:c,x2:d,y2:g,x:l,y:a}=s;return new F(r,o,i,c,d,g,l,a)}case"L":{const{x0:r,y0:o,x:i,y:c}=s;return new M(r,o,i,c)}case"Q":{const{x0:r,y0:o,x:i,y:c,creationInfo:d}=s;switch(d.source){case"angles":{const{angle0:g,angle:l}=d,a=E.angles(r,o,g,i,c,l);return(a.creationInfo.source!="angles"||a.creationInfo.success!=d.success)&&console.warn("different",s,a),a}case"controlPoints":{const{x1:g,y1:l}=s;return E.controlPoints(r,o,g,l,i,c)}case"line":return E.line4(r,o,i,c);default:throw new Error(`Unknown source: "${d.source}"`)}}default:throw new Error(`Unknown command: "${s.command}"`)}});return new $(e)}catch{return}}matchForMorph(t){const n=this.commands.map(i=>i.toCubic()),e=t.commands.map(i=>i.toCubic());if(n.length!=e.length){const{shorter:i,longer:c}=n.length<e.length?{shorter:n,longer:e}:{shorter:e,longer:n};if(i.length==0)throw new Error("can't morph something into nothing");const d=c.length/i.length,g=[];i.forEach((l,a)=>{const m=Math.round((a+1)*d);for(;g.length<m;)g.push(l)}),i.length=0,i.push(...g)}if(n.length!=e.length)throw new Error("wtf");function s(i){return $.cssifyPath(i.map(c=>new $([c]).rawPath).join())}const r=s(n),o=s(e);return[r,o]}commands;get endX(){return this.commands.at(-1)?.x}get endY(){return this.commands.at(-1)?.y}get startX(){return this.commands.at(0)?.x0}get startY(){return this.commands.at(0)?.y0}constructor(t){this.commands=[...t]}static cssifyPath(t){return`path('${t}')`}get cssPath(){return $.cssifyPath(this.rawPath)}makeElement(){const t=document.createElementNS("http://www.w3.org/2000/svg","path"),n=this.cssPath;if(t.style.d=n,t.style.d=="")throw console.error(n,t),new Error("wtf");return t}static needAnM(t,n){return n?!t||t.x!=n.x0||t.y!=n.y0:!1}get rawPath(){return this.splitOnMove().flatMap(t=>{const n=[`M ${v(t.startX)},${v(t.startY)}`];return t.commands.forEach(e=>n.push(e.asString)),t.startX==t.endX&&t.startY==t.endY&&n.push("Z"),n}).join(" ")}get cssPaths(){return this.splitOnMove().map(t=>t.cssPath)}get rawPaths(){return this.splitOnMove().map(t=>t.rawPath)}splitOnMove(){const t=[];let n=[];return this.commands.forEach(e=>{$.needAnM(n.at(-1),e)&&(n=[],t.push(n)),n.push(e)}),t.map(e=>new $(e))}static join(t){return new $(t.flatMap(({Δx:n,Δy:e,shape:s})=>s.translate(n,e).commands))}convertToCubics(){return new $(this.commands.map(t=>t.toCubic()))}translate(t,n){return new $(this.commands.map(e=>e.translate(t,n)))}static fixAngleRounding(t){return t+400-400}static toDegrees(t){return Math.round(t*h.degreesPerRadian*100)/100}dump(){const t=this.commands.map((n,e)=>{const{x0:s,y0:r,x:o,y:i,incomingAngle:c,outgoingAngle:d,command:g}=n,l=document.createElementNS("http://www.w3.org/2000/svg","path");l.setAttribute("d",new $([n]).rawPath);const a=l.getTotalLength(),m=this.commands[e-1],w=$.needAnM(m,n)?{}:{difference:$.toDegrees(h.angleBetween(m.outgoingAngle,c))};return{x0:s,y0:r,x:o,y:i,incomingAngle:$.toDegrees(c),outgoingAngle:$.toDegrees(d),length:a,c:g,...w}});console.table(t),console.log(this.rawPath),console.log(JSON.stringify(this))}}function G(x,t){if(h.assertFinite(x.x0,x.y0,x.angle,t.x0,t.y0,t.angle),isNaN(x.angle)||isNaN(t.angle)||x.angle==t.angle)return;const n=Math.tan(x.angle),e=Math.tan(t.angle),s=Math.abs(n)*100>Number.MAX_SAFE_INTEGER,r=Math.abs(e)*100>Number.MAX_SAFE_INTEGER;if(s&&r)return;const o=Math.atan2(t.y0-x.y0,t.x0-x.x0),i=h.angleBetween(x.angle,o),c=h.angleBetween(t.angle,o);if(i==0||Math.abs(c)==Math.PI){if(Math.abs(i)==Math.PI||c==0)return;const l=(x.x0+t.x0)/2,a=(x.y0+t.y0)/2;return{x:l,y:a}}const d=Math.sign(i),g=Math.sign(c);if(!(d!=g||d==0)&&!(Math.abs(c)<=Math.abs(i)+h.radiansPerDegree))if(s||r){const l=s?x.x0:t.x0,a=s?{...t,slope:e}:{...x,slope:n},m=a.slope*(l-a.x0)+a.y0;return{x:l,y:m}}else{const l=(t.y0-e*t.x0-x.y0+n*x.x0)/(n-e),a=n*(l-x.x0)+x.y0;return{x:l,y:a}}}export{M as L,$ as P,E as Q,U as a,N as b};
