import"./modulepreload-polyfill-B5Qt9EMX.js";import{c as P}from"./client-misc-ZHNZ3-cL.js";import{s as v,b as E}from"./utility-D9E8BDCl.js";import{P as w}from"./path-shape-fljILaqi.js";import{m as p}from"./misc-wGF4FraP.js";const g=1e-4;function O(o){const t=o*Math.PI;return(1-Math.cos(t))/2}class b{compute(t,n,s){let a=0;for(let e=0;e<s;e++){const i=this.constant(n,e);a+=i*(t-n)**e}return a}validRanges(){const t=this.badPoints.flatMap(({real:s,imaginary:a})=>a==0?[s]:[]).sort((s,a)=>s-a);return t.push(1/0),t.map((s,a,e)=>({from:(e[a-1]??-1/0)+g,to:s-g}))}radiusOfConvergence(t){return Math.min(...this.badPoints.map(n=>Math.hypot(t-n.real,n.imaginary)))}partialSum(t,n){const s=p.initializedArray(n,e=>this.constant(t,e));function a(e){const i=e-t;let r=0;return s.forEach((c,l)=>r+=c*i**l),r}return a}}class V extends b{numberOfTerms=1/0;constant(t,n){if(t===0)throw new Error("Reciprocal is undefined at x0 = 0");return(-1)**n/t**(n+1)}f(t){if(t===0)throw new Error("Reciprocal is undefined at x = 0");return 1/t}static instance=new this;badPoints=[{real:0,imaginary:0}]}class R extends b{numberOfTerms=1/0;constant(t,n){const s=t+n*Math.PI/2;let a=1;for(let e=1;e<=n;e++)a*=e;return Math.sin(s)/a}f(t){return Math.sin(t)}static instance=new this;badPoints=[]}class M extends b{numberOfTerms=12;constant(t,n){const s=1+t*t;switch(n){case 0:return 1/s;case 1:return-2*t/s**2;case 2:return(3*t*t-1)/s**3;case 3:return 2*t*(3-5*t*t)/s**4;case 4:return(25*t**4-38*t*t+3)/(2*s**5);case 5:return t*(2842*t*t-1450*t**4-636)/(5*s**6);case 6:return(-7700*t**6+20316*t**4-9120*t*t+216)/(12*s**7);case 7:return t*(29718*t**4-46410*t*t+10869)/(3*s**8);case 8:return(159600*t**8-498960*t**6+424116*t**4-90456*t*t+2268)/(48*s**9);case 9:return t*(-672452*t**6+1660530*t**4-987318*t*t+117693)/(30*s**10);case 10:return(8044400*t**10-30524376*t**8+35128260*t**6-13524948*t**4+1475730*t*t-18360)/(720*s**11);case 11:return t*(29887350*t**8-96204090*t**6+87415950*t**4-22994430*t*t+1596795)/(180*s**12);default:throw new Error(`Term ${n} not implemented.`)}}f(t){return 1/(1+t*t)}static instance=new this;badPoints=[{real:0,imaginary:1},{real:0,imaginary:-1}]}class d{#t;#s;#n;#e;constructor(t){[this.#t,this.#s]=v(`[data-open-end="${t}"]`,SVGCircleElement,2,2),this.#n=E(`[data-center="${t}"]`,SVGCircleElement),this.#e=E(`[data-reconstruction="${t}"]`,SVGPathElement)}hide(){this.#t.style.display="none",this.#s.style.display="none",this.#n.style.display="none",this.#e.style.d=""}draw2(t,n,s,a,e){function i(r){const c=t(r),l=n(r);return c*(1-s)+l*s}this.draw(i,a,e)}draw(t,n,s){if(s-=g,s<=0)throw new Error("wtf");const a=-9,e=9,i=n-s,r=n+s,c=Math.max(a,i),l=Math.min(e,r),m=u=>{isFinite(s)&&(u=O(u));const f=p.lerp(c,l,u),y=t(f);return{x:f,y}},h=w.parametric(m,50);this.#e.style.d=h.cssPath,this.#n.style.display="",this.#n.cx.baseVal.value=n,this.#n.cy.baseVal.value=t(n),isFinite(s)?(this.#t.style.display="",this.#s.style.display="",this.#t.cx.baseVal.value=i,this.#t.cy.baseVal.value=t(i),this.#s.cx.baseVal.value=r,this.#s.cy.baseVal.value=t(r)):(this.#t.style.display="none",this.#s.style.display="none")}precompute(t,n,s){const a=t.radiusOfConvergence(n),e=p.initializedArray(s,r=>t.partialSum(n,r));return r=>{if(r>e.length-1)throw new Error(`Requested: ${r}, Available [0 - ${e.length-1}]`);if(Number.isInteger(r))this.draw(e[r],n,a);else{let c=function(u){const f=l(u),y=m(u);return f*(1-h)+y*h};const l=e[Math.floor(r)],m=e[Math.ceil(r)],h=r%1;this.draw(c,n,a)}}}drawAll(t,n,s){}static instances=[new this("1"),new this("2"),new this("3")]}class I{#t=P.getById("original-function",SVGPathElement);hide(){this.#t.style.d=""}draw(t){const a=t.validRanges().flatMap(i=>{const r=Math.max(-9,i.from),c=Math.min(9,i.to);if(r>=c)return[];{const l=h=>{const u=p.lerp(r,c,h),f=t.f(u);return{x:u,y:f}};return w.parametric(l,Math.ceil((c-r)*5)).commands}}),e=new w(a);this.#t.style.d=e.cssPath}static instance=new this}console.log({HiddenPoles:M,Sine:R,Reciprocal:V,TaylorElements:d});{let o=function(s,a){const e=t.radiusOfConvergence(a);s.draw(t.f,a,e)};const t=M.instance;I.instance.draw(t),o(d.instances[0],-2),o(d.instances[1],1),o(d.instances[2],2.5);const n=d.instances[0].precompute(t,-2,Math.min(30,t.numberOfTerms));console.log(n),window.fff=n,n(M.instance.numberOfTerms-1.5)}
