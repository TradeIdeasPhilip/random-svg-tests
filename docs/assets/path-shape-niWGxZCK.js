import{m}from"./misc-DNuEEHQP.js";function U(u){const t=u.e,n=u.f,e=u.a,s=u.d,i=Math.atan(u.b/e),o=Math.atan(u.c/s),r=[];return(t!=0||n!=0)&&r.push(`translate(${t}px, ${n}px)`),(i!=0||o!=0)&&r.push(`skew(${i}rad, ${o}rad)`),(e!=1||s!=1)&&(e==s?r.push(`scale(${e})`):r.push(`scale(${e}, ${s})`)),r.join(" ")}window.unmatrix=U;function b(u,t,n){return new DOMPoint(u,t).matrixTransform(n)}function at(u,t){const n=t.width/u.width,e=t.height/u.height,s=u.x*n,i=u.y*e,o=t.x-s,r=t.y-i,c=`translate(${o}px, ${r}px) scale(${n}, ${e})`;return{xScale:n,yScale:e,transformString:c}}function ht(u,t,n,e=.5,s=.5){return new DOMMatrix(j(u,t,n,e,s))}function j(u,t,n,e=.5,s=.5){const i=u.width/u.height,o=t.width/t.height;let r;switch(n){case"meet":case"srcRect fits completely into destRect":{i>o?r=t.width/u.width:r=t.height/u.height;break}case"slice":case"srcRect completely covers destRect":{i>o?r=t.height/u.height:r=t.width/u.width;break}default:throw new Error("wtf")}const c=-u.x*r+e*(t.width-u.width*r)+t.x,l=-u.y*r+s*(t.height-u.height*r)+t.y;return`translate(${c}px, ${l}px) scale(${r})`}function lt(u,t){const n=u.getCTM(),e=t.getCTM();if(!n||!e)throw new Error("Unable to compute CTM for one or both elements");return e.inverse().multiply(n)}class q{#n=document.createElementNS("http://www.w3.org/2000/svg","svg");#t=document.createElementNS("http://www.w3.org/2000/svg","path");constructor(){this.#n.style.width="0",this.#n.style.height="0",this.#n.style.position="absolute",this.#n.appendChild(this.#t),document.body.appendChild(this.#n)}getBBox(){return this.#t.getBBox()}get d(){return this.#t.getAttribute("d")??""}set d(t){this.#t.style.d="",this.#t.style.d=p.cssifyPath(t);const n=this.#t.style.d!="";if(this.#t.style.d="",n)this.#t.setAttribute("d",t);else throw new Error("Invalid path")}get empty(){return this.d==""}clear(){this.d=""}get length(){return this.#t.getTotalLength()}getPoint(t){return this.#t.getPointAtLength(t)}load(t){typeof t!="string"&&(t instanceof p||(t=new p([t])),t=t.rawPath),this.d=t}measure(t){return this.load(t),this.length}}const C=new Intl.NumberFormat("en-US",{maximumSignificantDigits:8,useGrouping:!1}).format;class E{constructor(t,n,e,s){this.x0=t,this.y0=n,this.x=e,this.y=s,m.assertFinite(t,n,e,s),this.asString=`L ${C(e)},${C(s)}`,this.outgoingAngle=this.incomingAngle=Math.atan2(s-n,e-t)}reverse(){return new E(this.x,this.y,this.x0,this.y0)}toJSON(){return{command:"L",x0:this.x0,y0:this.y0,x:this.x,y:this.y}}static relative(t,n,e,s){return new this(t,n,e+t,s+n)}incomingAngle;outgoingAngle;command="L";asString;get length(){return Math.hypot(this.x0-this.x,this.y0-this.y)}translate(t,n){return new E(this.x0+t,this.y0+n,this.x+t,this.y+n)}toCubic(){return new I(this.x0,this.y0,m.lerp(this.x0,this.x,1/3),m.lerp(this.y0,this.y,1/3),m.lerp(this.x0,this.x,2/3),m.lerp(this.y0,this.y,2/3),this.x,this.y)}transform(t){const n=b(this.x,this.y,t),e=b(this.x0,this.y0,t);return new E(e.x,e.y,n.x,n.y)}}class M{constructor(t,n,e,s,i,o,r){this.x0=t,this.y0=n,this.x1=e,this.y1=s,this.x=i,this.y=o,this.creationInfo=r,m.assertFinite(t,n,e,s,i,o),this.asString=`Q ${C(e)},${C(s)} ${C(i)},${C(o)}`}reverse(){return M.controlPoints(this.x,this.y,this.x1,this.y1,this.x0,this.y0)}static line(t,n,e,s,i){return new this(t,n,(t+e)/2,(n+s)/2,e,s,i)}static line4(t,n,e,s){return this.line(t,n,e,s,{source:"line"})}static line2(t,n){return this.line4(t.x,t.y,n.x,n.y)}static angles(t,n,e,s,i,o){m.assertFinite(t,n,e,s,i,o);const r=it({x0:t,y0:n,angle:e},{x0:s,y0:i,angle:o+Math.PI});return r?new this(t,n,r.x,r.y,s,i,{source:"angles",success:!0,angle:o,angle0:e}):this.line(t,n,s,i,{source:"angles",success:!1,angle:o,angle0:e})}newAngles(t,n){return t??=this.requestedIncomingAngle,n??=this.requestedOutgoingAngle,M.angles(this.x0,this.y0,t,this.x,this.y,n)}toJSON(){return{command:"Q",x0:this.x0,y0:this.y0,x1:this.x1,y1:this.y1,x:this.x,y:this.y,creationInfo:this.creationInfo}}static controlPoints(t,n,e,s,i,o){return new this(t,n,e,s,i,o,{source:"controlPoints"})}static relative(t,n,e,s,i,o){return this.controlPoints(t,n,e+t,s+n,i+t,o+n)}get incomingAngle(){return Math.atan2(this.y1-this.y0,this.x1-this.x0)}get outgoingAngle(){return Math.atan2(this.y-this.y1,this.x-this.x1)}get requestedIncomingAngle(){return this.creationInfo.source=="angles"?this.creationInfo.angle0:this.incomingAngle}get requestedOutgoingAngle(){return this.creationInfo.source=="angles"?this.creationInfo.angle:this.outgoingAngle}command="Q";asString;translate(t,n){return M.controlPoints(this.x0+t,this.y0+n,this.x1+t,this.y1+n,this.x+t,this.y+n)}transform(t){const n=b(this.x0,this.y0,t),e=b(this.x1,this.y1,t),s=b(this.x,this.y,t);return M.controlPoints(n.x,n.y,e.x,e.y,s.x,s.y)}toCubic(){return new I(this.x0,this.y0,m.lerp(this.x0,this.x1,2/3),m.lerp(this.y0,this.y1,2/3),m.lerp(this.x,this.x1,2/3),m.lerp(this.y,this.y1,2/3),this.x,this.y)}split(t){const{x:n,x0:e,x1:s,y:i,y0:o,y1:r}=this,c=e,l=o,h=(1-t)*e+t*s,d=(1-t)*o+t*r,a=(1-t)**2*e+2*(1-t)*t*s+t**2*n,f=(1-t)**2*o+2*(1-t)*t*r+t**2*i,y=M.controlPoints(c,l,h,d,a,f),w=a,$=f,A=(1-t)*s+t*n,v=(1-t)*r+t*i,F=n,T=i,L=M.controlPoints(w,$,A,v,F,T);return[y,L]}multiSplit(t){if(m.assertFinite(t),t<1||(t|0)!=t)throw new Error("wtf");const n=[];let e=this;for(;t>1;){const s=1/t;let i;[i,e]=e.split(s),n.push(i),t--}return n.push(e),n}}class I{constructor(t,n,e,s,i,o,r,c){this.x0=t,this.y0=n,this.x1=e,this.y1=s,this.x2=i,this.y2=o,this.x=r,this.y=c,m.assertFinite(t,n,e,s,i,o,r,c),this.asString=`C ${C(e)},${C(s)} ${C(i)},${C(o)} ${C(r)},${C(c)}`}reverse(){return new I(this.x,this.y,this.x2,this.y2,this.x1,this.y1,this.x0,this.y0)}static relative(t,n,e,s,i,o,r,c){return new this(t,n,e+t,s+n,i+t,o+n,r+t,c+n)}get incomingAngle(){return Math.atan2(this.y1-this.y0,this.x1-this.x0)}get outgoingAngle(){return Math.atan2(this.y-this.y2,this.x-this.x2)}command="C";asString;translate(t,n){return new I(this.x0+t,this.y0+n,this.x1+t,this.y1+n,this.x2+t,this.y2+n,this.x+t,this.y+n)}transform(t){const n=b(this.x0,this.y0,t),e=b(this.x1,this.y1,t),s=b(this.x2,this.y2,t),i=b(this.x,this.y,t);return new I(n.x,n.y,e.x,e.y,s.x,s.y,i.x,i.y)}toCubic(){return this}}class S{get commands(){return this.#n}addCommand(t){this.#n.push(t),this.#t=void 0}addCommands(t){return t.forEach(n=>this.addCommand(n)),this}static fromStrings(t){let n=t.join(" ");const e=[];let s;for(;n=n.replace(/^ */,""),n!="";){let i=Q.exec(n);if(i){const o=m.parseFloatX(i[1]),r=m.parseFloatX(i[2]);if(o===void 0||r===void 0)throw console.error(i,o,r,this),new Error("wtf");s&&e.push(s),s=this.M(o,r),n=i[3];continue}if(s){if(i=Y.exec(n),i){const o=m.parseFloatX(i[1]),r=m.parseFloatX(i[2]);if(o===void 0||r===void 0)throw console.error(i,o,r,this),new Error("wtf");s=s.L(o,r),n=i[3];continue}if(i=z.exec(n),i){const o=m.parseFloatX(i[1]),r=m.parseFloatX(i[2]),c=m.parseFloatX(i[3]),l=m.parseFloatX(i[4]);if(o===void 0||r===void 0||c===void 0||l===void 0)throw console.error(i,o,r,c,l,this),new Error("wtf");s=s.Q(o,r,c,l),n=i[5];continue}if(i=J.exec(n),i){const o=m.parseFloatX(i[1]),r=m.parseFloatX(i[2]),c=m.parseFloatX(i[3]),l=m.parseFloatX(i[4]),h=m.parseFloatX(i[5]),d=m.parseFloatX(i[6]);if(o===void 0||r===void 0||c===void 0||l===void 0||h===void 0||d===void 0)throw console.error(i,o,r,c,l,h,d,this),new Error("wtf");s=s.C(o,r,c,l,h,d),n=i[7];continue}}throw console.error(n),new Error("wtf")}return s&&e.push(s),e}static M(t,n){const e=new S;return e.M(t,n),e}#n=[];get pathShape(){return new p(this.#n)}#t;M(t,n,e=NaN){return m.assertFinite(t,n),this.#t={x:t,y:n,outgoingAngle:e},this}previous(){return this.#t??this.#n.at(-1)}H(t){const n=this.previous();return this.addCommand(new E(n.x,n.y,t,n.y)),this}V(t){const n=this.previous();return this.addCommand(new E(n.x,n.y,n.x,t)),this}L(t,n){const e=this.previous();return this.addCommand(new E(e.x,e.y,t,n)),this}Q(t,n,e,s){const i=this.previous();return this.addCommand(M.controlPoints(i.x,i.y,t,n,e,s)),this}Q_HV(t,n){const e=this.previous();return this.Q(t,e.y,t,n)}Q_VH(t,n){const e=this.previous();return this.Q(e.x,n,t,n)}Q_angles(t,n,e,s){const i=this.previous();if(s??=i.outgoingAngle,s===void 0)throw new Error("wtf");return this.addCommand(M.angles(i.x,i.y,s,t,n,e)),this}C(t,n,e,s,i,o){const r=this.previous();return this.addCommand(new I(r.x,r.y,t,n,e,s,i,o)),this}circle(t,n,e="cw"){const s=this.previous(),i=s.x,o=s.y,r=Math.atan2(o-n,i-t),c=Math.hypot(o-n,i-t),l=e=="cw"?1:-1,h=r+Math.PI*2*l,d=m.makeLinear(0,r,1,h);function a(w){switch(w){case 0:case 1:return s;default:{const $=d(w),A=m.polarToRectangular(c,$);return{x:t+A.x,y:n+A.y}}}}function f(w){return a(w)}return this.addParametricPath(f,8),this}arc(t,n,e,s,i){const o=this.previous(),r=o.x,c=o.y;let l=m.positiveModulo(Math.atan2(c-n,r-t),Math.PI*2);const h=Math.hypot(c-n,r-t);let d=m.positiveModulo(Math.atan2(s-n,e-t),Math.PI*2);const a=Math.hypot(s-n,e-t);i=="cw"?l>d&&(d+=Math.PI*2):l<d&&(l+=Math.PI*2);const f=Math.abs(l-d),y=Math.ceil(f*1.17+1e-4),w=m.makeLinear(0,h,1,a),$=m.makeLinear(0,l,1,d);function A(v){switch(v){case 0:return o;case 1:return{x:e,y:s};default:{const F=m.polarToRectangular(w(v),$(v));return{x:t+F.x,y:n+F.y}}}}return this.addParametricPath(A,y)}addParametricPath(t,n){if(n<=0)throw new Error("wtf");const e=1e-4/n,s=m.initializedArray(n+1,i=>{const o=i/n,r=t(o),c=D(t,o,e);return{t:o,point:r,direction:c}});if(s.some(i=>!isFinite(i.direction))){const{x:i,y:o}=s[0].point;if(m.assertFinite(i,o),s.some(r=>r.point.x!=i||r.point.y!=o))throw new Error("Unable to create a path from this function.  Unable to compute the derivative.");for(let r=0;r<n;r++)this.Q(i,o,i,o)}else m.initializedArray(n,o=>({from:s[o],to:s[o+1]})).forEach(o=>{this.Q_angles(o.to.point.x,o.to.point.y,o.to.direction,o.from.direction)});return this}}function O(u,t,n){if(!(t>=0&&t<=1))throw new Error("Expected 0 ≤ t ≤ 1");const e=Math.max(0,t-n),s=u(e),i=Math.min(1,t+n),o=u(i),r=o.x-s.x,c=o.y-s.y;return r==0&&c==0?NaN:Math.atan2(c,r)}function D(u,t,n){const e=O(u,t,n*2),s=O(u,t,n*1),i=e-s;return s-i}const P=" *",g="(-?[0-9]+\\.?[0-9]*(?:[eE][-+]?[0-9]+)?)",x="(?: *[, ] *|(?=-))",Q=new RegExp(`^M${P}${g}${x}${g}(.*)$`),V=new RegExp(`^m${P}${g}${x}${g}(.*)$`),Y=new RegExp(`^L${P}${g}${x}${g}(.*)$`),R=new RegExp(`^${x}${g}${x}${g}(.*)$`),G=new RegExp(`^l${P}${g}${x}${g}(.*)$`),H=new RegExp(`^H${P}${g}(.*)$`),Z=new RegExp(`^h${P}${g}(.*)$`),K=new RegExp(`^V${P}${g}(.*)$`),W=new RegExp(`^v${P}${g}(.*)$`),B=new RegExp(`^${x}${g}(.*)$`),_=B,z=new RegExp(`^Q${P}${g}${x}${g}${x}${g}${x}${g}(.*)$`),tt=new RegExp(`^${x}${g}${x}${g}${x}${g}${x}${g}(.*)$`),nt=new RegExp(`^q${P}${g}${x}${g}${x}${g}${x}${g}(.*)$`),J=new RegExp(`^C${P}${g}${x}${g}${x}${g}${x}${g}${x}${g}${x}${g}(.*)$`),k=new RegExp(`^${x}${g}${x}${g}${x}${g}${x}${g}${x}${g}${x}${g}(.*)$`),et=new RegExp(`^c${P}${g}${x}${g}${x}${g}${x}${g}${x}${g}${x}${g}(.*)$`),st=new RegExp("^[zZ](.*)$");class ot extends Error{constructor(t,n){super(t),this.where=n}}class p{reverse(){return new p(this.commands.toReversed().map(t=>t.reverse()))}static fromString(t){const n=this.fromJson(t);if(n)return n;let e=t,s=null;const i=a=>new ot(a,e),o=a=>{const f=m.parseFloatX(a);if(f===void 0)throw i(`Invalid number: "${a}"`);return f};let r=0,c=0;const l=[],h=a=>{l.push(a),r=a.x,c=a.y};let d;for(;e=e.replace(/^ */,""),e!="";){if(s=Q.exec(e)){r=o(s[1]),c=o(s[2]),d={x0:r,y0:c},e=s[3];continue}if(s=V.exec(e)){for(r+=o(s[1]),c+=o(s[2]),d={x0:r,y0:c},e=s[3];s=R.exec(e);){const a=E.relative(r,c,o(s[1]),o(s[2]));h(a),e=s[3]}continue}if(!d)throw i("Must start with an M command.");if(s=st.exec(e)){if(r!=d.x0||c!=d.y0){const a=new E(r,c,d.x0,d.y0);h(a)}e=s[1];continue}if(s=Y.exec(e)){const a=o(s[1]),f=o(s[2]),y=new E(r,c,a,f);h(y),e=s[3];continue}if(s=G.exec(e)){for(;s;){const a=o(s[1]),f=o(s[2]),y=E.relative(r,c,a,f);h(y),e=s[3],s=R.exec(e)}continue}if(s=H.exec(e)){const a=o(s[1]),f=new E(r,c,a,c);h(f),e=s[2];continue}if(s=Z.exec(e)){for(;s;){const a=o(s[1]),f=new E(r,c,r+a,c);h(f),e=s[2],s=_.exec(e)}continue}if(s=K.exec(e)){const a=o(s[1]),f=new E(r,c,r,a);h(f),e=s[2];continue}if(s=W.exec(e)){for(;s;){const a=o(s[1]),f=new E(r,c,r,c+a);h(f),e=s[2],s=B.exec(e)}continue}if(s=z.exec(e)){const a=o(s[1]),f=o(s[2]),y=o(s[3]),w=o(s[4]),$=M.controlPoints(r,c,a,f,y,w);h($),e=s[5];continue}if(s=nt.exec(e)){for(;s;){const a=o(s[1]),f=o(s[2]),y=o(s[3]),w=o(s[4]),$=M.relative(r,c,a,f,y,w);h($),e=s[5],s=tt.exec(e)}continue}if(s=J.exec(e)){for(;s;){const a=o(s[1]),f=o(s[2]),y=o(s[3]),w=o(s[4]),$=o(s[5]),A=o(s[6]),v=new I(r,c,a,f,y,w,$,A);h(v),e=s[7],s=k.exec(e)}continue}if(s=et.exec(e)){for(;s;){const a=o(s[1]),f=o(s[2]),y=o(s[3]),w=o(s[4]),$=o(s[5]),A=o(s[6]),v=I.relative(r,c,a,f,y,w,$,A);h(v),e=s[7],s=k.exec(e)}continue}throw i("Confused.")}return new this(l)}static fromJson(t){try{const e=JSON.parse(t).commands.map(s=>{switch(s.command){case"C":{const{x0:i,y0:o,x1:r,y1:c,x2:l,y2:h,x:d,y:a}=s;return new I(i,o,r,c,l,h,d,a)}case"L":{const{x0:i,y0:o,x:r,y:c}=s;return new E(i,o,r,c)}case"Q":{const{x0:i,y0:o,x:r,y:c,creationInfo:l}=s;switch(l.source){case"angles":{const{angle0:h,angle:d}=l,a=M.angles(i,o,h,r,c,d);return(a.creationInfo.source!="angles"||a.creationInfo.success!=l.success)&&console.warn("different",s,a),a}case"controlPoints":{const{x1:h,y1:d}=s;return M.controlPoints(i,o,h,d,r,c)}case"line":return M.line4(i,o,r,c);default:throw new Error(`Unknown source: "${l.source}"`)}}default:throw new Error(`Unknown command: "${s.command}"`)}});return new p(e)}catch{return}}matchForMorph(t){const n=this.commands.map(r=>r.toCubic()),e=t.commands.map(r=>r.toCubic());if(n.length!=e.length){const{shorter:r,longer:c}=n.length<e.length?{shorter:n,longer:e}:{shorter:e,longer:n};if(r.length==0)throw new Error("can't morph something into nothing");const l=c.length/r.length,h=[];r.forEach((d,a)=>{const f=Math.round((a+1)*l);for(;h.length<f;)h.push(d)}),r.length=0,r.push(...h)}if(n.length!=e.length)throw new Error("wtf");function s(r){return p.cssifyPath(r.map(c=>new p([c]).rawPath).join())}const i=s(n),o=s(e);return[i,o]}commands;get endX(){return this.commands.at(-1)?.x}get endY(){return this.commands.at(-1)?.y}get startX(){return this.commands.at(0)?.x0}get startY(){return this.commands.at(0)?.y0}constructor(t){this.commands=[...t]}static cssifyPath(t){return`path('${t}')`}get cssPath(){return p.cssifyPath(this.rawPath)}makeElement(t=!0){const n=document.createElementNS("http://www.w3.org/2000/svg","path");if(t){const e=this.cssPath;if(n.style.d=e,n.style.d=="")throw console.error(e,n),new Error("wtf")}else n.setAttribute("d",this.rawPath);return n}static needAnM(t,n){return n?!t||t.x!=n.x0||t.y!=n.y0:!1}get rawPath(){return this.splitOnMove().flatMap(t=>{const n=[`M ${C(t.startX)},${C(t.startY)}`];return t.commands.forEach(e=>n.push(e.asString)),t.startX==t.endX&&t.startY==t.endY&&n.push("Z"),n}).join(" ")}splitOnMove(){const t=[];let n=[];return this.commands.forEach(e=>{p.needAnM(n.at(-1),e)&&(n=[],t.push(n)),n.push(e)}),t.map(e=>new p(e))}static join(t){return new p(t.flatMap(({Δx:n,Δy:e,shape:s})=>s.translate(n,e).commands))}convertToCubics(){return new p(this.commands.map(t=>t.toCubic()))}translate(t,n){return new p(this.commands.map(e=>e.translate(t,n)))}transform(t){return new p(this.commands.map(n=>n.transform(t)))}static parametric(t,n){const e=t(0);return S.M(e.x,e.y).addParametricPath(t,n).pathShape}static glitchFreeParametric(t,n){const e=this.#t(t,n,0);return m.assertNonNullable(e)}static#n=new q;static#t(t,n,e){if(e>=4){console.log("⚝");return}const i=this.parametric(t,n).commands.map((c,l,h)=>{const d=l/h.length,a=(l+1)/h.length;return{command:c,initialT:d,finalT:a}});let o=0;const r=c=>{const l=new this([c]);this.#n.d=l.rawPath;const h=this.#n.length,d=Math.hypot(c.x0-c.x,c.y0-c.y),a=h/d;return a<2||!isFinite(a)};for(;o<i.length;){const c=i[o].command;if(r(c))o++;else{const l=Math.max(0,o-1);let h=o+1;for(;h<i.length;){const v=i[h].command;if(h++,r(v))break}const d=i[l].initialT,a=i[h-1].finalT,f=m.makeLinear(0,d,1,a),y=v=>t(f(v)),w=h-l,$=w+1,A=this.#t(y,$,e+1);if(A===void 0){if(e>0)return;const v=i[o],{x0:F,y0:T,x:L,y:N}=v.command;v.command=M.line4(F,T,L,N),o++}else i.splice(l,w,...A.commands.map((v,F,T)=>{const L=f(F/T.length),N=f((F+1)/T.length);return{command:v,initialT:L,finalT:N}})),o+=$}}return new p(i.map(c=>c.command))}static fixAngleRounding(t){return t+400-400}static toDegrees(t){return Math.round(t*m.degreesPerRadian*100)/100}dump(){const t=this.commands.map((n,e)=>{const{x0:s,y0:i,x:o,y:r,incomingAngle:c,outgoingAngle:l,command:h}=n,d=document.createElementNS("http://www.w3.org/2000/svg","path");d.setAttribute("d",new p([n]).rawPath);const a=d.getTotalLength(),f=this.commands[e-1],w=p.needAnM(f,n)?{}:{difference:p.toDegrees(m.angleBetween(f.outgoingAngle,c))};return{x0:s,y0:i,x:o,y:r,incomingAngle:p.toDegrees(c),outgoingAngle:p.toDegrees(l),length:a,c:h,...w}});console.table(t),console.log(this.rawPath),console.log(JSON.stringify(this))}}function it(u,t){if(m.assertFinite(u.x0,u.y0,u.angle,t.x0,t.y0,t.angle),isNaN(u.angle)||isNaN(t.angle)||u.angle==t.angle)return;const n=Math.tan(u.angle),e=Math.tan(t.angle),s=Math.abs(n)*100>Number.MAX_SAFE_INTEGER,i=Math.abs(e)*100>Number.MAX_SAFE_INTEGER;if(s&&i)return;const o=Math.atan2(t.y0-u.y0,t.x0-u.x0),r=m.angleBetween(u.angle,o),c=m.angleBetween(t.angle,o);if(r==0||Math.abs(c)==Math.PI){if(Math.abs(r)==Math.PI||c==0)return;const d=(u.x0+t.x0)/2,a=(u.y0+t.y0)/2;return{x:d,y:a}}const l=Math.sign(r),h=Math.sign(c);if(!(l!=h||l==0)&&!(Math.abs(c)<=Math.abs(r)+m.radiansPerDegree))if(s||i){const d=s?u.x0:t.x0,a=s?{...t,slope:e}:{...u,slope:n},f=a.slope*(d-a.x0)+a.y0;return{x:d,y:f}}else{const d=(t.y0-e*t.x0-u.y0+n*u.x0)/(n-e),a=n*(d-u.x0)+u.y0;return{x:d,y:a}}}function rt(u){if(!(u instanceof M))throw new Error("wtf");if(u.creationInfo.source!="angles")throw new Error("wtf");return u}class X{constructor(t,n=16,e){this.f=t;const s=p.parametric(t,n);this.#t=s.commands.map((i,o,r)=>{const c=o/r.length,l=(o+1)/r.length;return this.#e(c,l,rt(i))}).sort((i,o)=>i.metric-o.metric),e===void 0&&(X.#n.load(s),e=X.#n.getBBox()),typeof e!="number"&&(e=Math.hypot(e.height,e.width)),this.#s=.001*e}static#n=new q;#t;#s;get commands(){return this.#t}#o(t){this.#t.splice(this.#t.findLastIndex(n=>n.metric<=t.metric)+1,0,t)}#e(t,n,e){let i=0;{const c=[{x:e.x0,y:e.y0}];for(let l=1;l<4;l++){const h=l/4,d=m.lerp(t,n,h);c.push(this.f(d))}c.push({x:e.x,y:e.y}),c.forEach((l,h)=>{const d=c[h+1];d&&(i+=Math.hypot(l.x-d.x,l.y-d.y))})}const o=X.#n.measure(e),r=Math.abs(i-o);return e.creationInfo.success,{startT:t,endT:n,command:e,polyLineLength:i,curveLength:o,metric:r}}add(t){for(let n=0;n<t;n++)this.addOne()}addOne(){const t=this.#t.pop(),{startT:n,endT:e}=t,s=(n+e)/2,i=this.f(s),o=1e-4*(s-n),r=D(this.f,s,o),c=M.angles(t.command.x0,t.command.y0,t.command.requestedIncomingAngle,i.x,i.y,r),l=this.#e(n,s,c);this.#o(l);const h=M.angles(i.x,i.y,r,t.command.x,t.command.y,t.command.requestedOutgoingAngle),d=this.#e(s,e,h);return this.#o(d),{toSplit:t,firstCommandInfo:l,secondCommandInfo:d}}done(){return this.commands.at(-1).metric<this.#s}go(t=50){for(let n=0;n<t&&!this.done();n++)this.addOne()}get pathShape(){return new p(this.#t.toSorted((t,n)=>t.startT-n.startT).map(({command:t})=>t))}summarize(){function t(n){n.sort((h,d)=>h-d);const e=n.length;function s(h){const a=(n.length-1)*h;if(Number.isInteger(a))return n[a];{const f=Math.floor(a),y=f+1,w=a-f;return m.lerp(n[f],n[y],w)}}if(n.length<2)throw new Error("wtf");const i=m.initializedArray(5,h=>s(h/4));let o=0,r=0;n.forEach(h=>{o+=h,r+=h*h});const c=o/e,l=Math.sqrt((r-e*c*c)/(e-1));return{quartiles:i,mean:c,standardDeviation:l}}return{polyLineLength:t(this.#t.map(({polyLineLength:n})=>n)),curveLength:t(this.#t.map(({curveLength:n})=>n)),metric:t(this.#t.map(({metric:n})=>n)),tCoverage:t(this.#t.map(({startT:n,endT:e})=>e-n)),generation:t(this.#t.map(({startT:n,endT:e})=>-Math.log2(e-n))),count:this.#t.length}}dump(){console.table(this.commands.map(({startT:t,endT:n,metric:e,curveLength:s})=>({startT:t,tCoverage:n-t,generation:-Math.log2(n-t),metric:e,curveLength:s})))}static chordRatio(t){const n=m.FULL_CIRCLE/t,e=2*Math.sin(n/2);return n/e}}window.ParametricToPath=X;export{E as L,p as P,M as Q,ot as a,S as b,X as c,q as d,lt as e,ht as p,at as r};
