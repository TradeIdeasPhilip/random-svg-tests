<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <!-- <link rel="icon" type="image/svg+xml" href="/moon.svg" /> -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Complex Fourier Series</title>
    <script type="module" crossorigin src="./assets/ҩажәа-CcHOiqEq.js"></script>
    <link rel="modulepreload" crossorigin href="./assets/modulepreload-polyfill-B5Qt9EMX.js">
    <link rel="modulepreload" crossorigin href="./assets/misc-BHUyxQfl.js">
    <link rel="modulepreload" crossorigin href="./assets/client-misc-B8CxQsfg.js">
    <link rel="modulepreload" crossorigin href="./assets/path-shape-CZZKMsju.js">
    <link rel="modulepreload" crossorigin href="./assets/utility-Dgy6CMn3.js">
    <link rel="modulepreload" crossorigin href="./assets/math-to-path-DHD-XsCZ.js">
    <link rel="modulepreload" crossorigin href="./assets/letters-base-Diwx_0WQ.js">
    <link rel="modulepreload" crossorigin href="./assets/hershey-fonts-piKVRfc2.js">
    <link rel="modulepreload" crossorigin href="./assets/fourier-shared-D_q1jb1g.js">
    <link rel="modulepreload" crossorigin href="./assets/fourier-samples-BfgRDmmf.js">
    <link rel="stylesheet" crossorigin href="./assets/ҩажәа-zHfnX7Jb.css">
    <link rel="stylesheet" crossorigin href="./assets/style-DQ03UEvS.css">
  </head>
  <body>
    <h1>Function</h1>
    <p>
      What do you want to graph? Create a parametric function in JavaScript.
      Name it <code>f()</code>. For each input value <code>t</code>, between 0
      and 1, <code>f()</code> returns a point like
      <code>{ x: 1, y: -0.08333333 }</code>. You can do one time setup before
      defining <code>f()</code>. See the <a href="#examples">examples</a> and
      additional instructions, below.
    </p>
    <div style="display: flex; flex-direction: column">
      <textarea
        id="source"
        style="
          min-height: 5lh;
          height: 50vh;
          font-size: inherit;
          text-wrap: nowrap;
        "
        autocorrect="off"
        spellcheck="off"
      ></textarea>
    </div>
    <button id="go">Go</button>
    <select id="sampleCode">
      <option>Error</option>
      <option>Check console for details.</option>
    </select>
    <button id="nextSample">Next Sample</button>
    <h2 data-hide>Inputs</h2>
    <div id="inputsGroup">
      <p data-hide>
        You can access these sliders from inside your code. The name of each
        slider is written next to it <code>in blue</code>. The samples will
        update immediately as you move the slider.
      </p>
      <div id="inputs"></div>
      <button data-hide>Add Another Input</button>
    </div>
    <div id="error" class="error"></div>
    <h2 data-hide>Output</h2>
    <label style="display: flex; align-items: center"
      ><input type="checkbox" id="hide-text" />&nbsp;Hide Text</label
    >
    <p data-hide>
      The first image shows your function tracing out the path. The second image
      shows how well each approximation matches the original. The table details
      the progress in the second image.
    </p>
    <p data-hide>
      If you see a <span style="color: darkred">dark red</span> or
      <span style="color: pink">pink</span> line, that means that there's a
      problem drawing the <span style="color: red">red</span> line. If you see
      these extra lines, the normal solution is to ramp up the
      <code>support.sampleCount</code>.
    </p>
    <svg
      class="outlineSample"
      id="distanceVsT"
      data-sample
      viewBox="0 0 100 10"
      xmlns="http://www.w3.org/2000/svg"
      preserveAspectRatio="xMidYMid meet"
      style="border: thin lightgreen solid"
    >
      <circle data-distance></circle>
      <path></path>
      <circle data-t></circle>
    </svg>

    <svg
      class="outlineSample"
      id="requestedVsReconstructed"
      data-sample
      viewBox="0 0 100 10"
      xmlns="http://www.w3.org/2000/svg"
      preserveAspectRatio="xMidYMid meet"
      style="border: thin lightgreen solid"
    >
      <path></path>
      <path></path>
      <path></path>
      <path></path>
    </svg>

    <table id="progress">
      <tr>
        <td></td>
        <th>Circles</th>
        <th>Amplitude</th>
      </tr>
      <tr data-using>
        <th>Using</th>
        <td data-circles class="numbers"></td>
        <td data-amplitude class="numbers"></td>
      </tr>
      <tr data-adding>
        <th>Adding</th>
        <td data-circles class="numbers"></td>
        <td data-amplitude class="numbers"></td>
      </tr>
      <tr data-available>
        <th>Available</th>
        <td data-circles class="numbers"></td>
        <td data-amplitude class="numbers"></td>
      </tr>
    </table>

    <h1>More Information</h1>
    <p>My take on the classic problem.</p>
    <h2>Complex Fourier Series</h2>
    <p>
      In this context “complex” means 2 dimensional. This page will convert any
      function into a series of circles, called a Fourier series. Add the
      circles back together to get the original function. Circles (or sines and
      cosines) are often essential because they easier to use than the original
      function.
    </p>
    <p>
      This page lets you <i>explore</i> the Fourier series for a function. You
      can see how well the series approximates the original function, and how
      quickly it converges. And you can tweak the function and its
      parameterization to see the result.
    </p>
    <p>
      The input to this page is a parametric function written in JavaScript.
      Your function takes one input, <code>t</code>, and returns a point. As
      <code>t</code> goes from 0 to 1, your function will trace out a path.
    </p>
    <p>
      Different functions can trace out the same path. These are called
      different “parameterizations.” The small,
      <span style="color: rgb(0, 195, 255)">light blue</span> dot traces out the
      results of your function as <code>t</code> increases at a constant rate.
      The <span style="color: red">red</span> dot always moves at a constant
      speed, as a point of comparison.
    </p>
    <p>
      The “Square” and “Square with Easing” examples show two parameterizations
      of the same shape. The former uses the simplest parameterization where the
      small <span style="color: rgb(0, 195, 255)">blue</span> dot is always
      moving at a constant speed. In the latter example the
      <span style="color: rgb(0, 195, 255)">blue</span> dot slows down around
      each of the corners, like a physical object would have to, speeding up
      through the straightaways. The latter example converges faster than the
      former, perhaps because sharp corners are difficult for a Fourier series,
      and this function spent more time around those trouble spots.
    </p>
    <h2>References</h2>
    <ul>
      <li>
        <a href="https://youtu.be/dV7GpeuyMNQ?si=V8E-OOBeQVQXLJAB"
          >This video</a
        >
        will give you an overview of this page.
      </li>
      <li>
        You can find general information about this project
        <a
          href="https://github.com/TradeIdeasPhilip/random-svg-tests/tree/master"
          >here</a
        >.
      </li>
      <li>
        All Things Physics’s
        <a
          href="https://www.youtube.com/playlist?list=PLQ05HUwVKT_RMKI07zbYw3_V87qCiSQ86"
          >Square Orbits and Fourier Series</a
        >
        playlist is a great place to get started. Those videos were my primary
        motivation and resource for creating this page.
      </li>
    </ul>
    <h2>JavaScript Support</h2>
    <p>
      You have access to all of JavaScript. You also have access to a variable
      called <code>support</code> which provides access to the following:
    </p>
    <ul>
      <li>
        <code>support.input()</code> &mdash; You can call
        <code>support.input(n)</code> to read a value from one of the sliders on
        this page. 0 for the first slider, 1 for the second, etc. The value will
        always come back in the range 0-1. (I’m looking at an improved UI, but
        this works for now.)
      </li>
      <li>
        <code>support.ease()</code> &mdash; You can say
        <code>t = support.ease(t)</code> to convert the default linear timing
        function into a timing function that eases in and out. The derivative of
        this function is 0 around t=0 and t=1. This function is shaped like half
        of a sine wave.
      </li>
      <li>
        <code>support.makeTSplitter()</code> &mdash; This is way to split a
        parametric function into smaller parts. Typically you’d call this once
        in the setup part of the script, before defining <code>f()</code>. This
        takes <i>a list of bin sizes as an input</i>. This returns a function
        that you will call inside of <code>f()</code>.
        <a
          href="https://github.com/TradeIdeasPhilip/random-svg-tests/blob/4b3583e48a336d21571e8974ca66e4b926baeb0e/src/utility.ts#L280"
          >Full documentation</a
        >.
      </li>
      <li>
        <code>support.makeTSplitterA()</code> &mdash; This is way to split a
        parametric function into smaller parts. Typically you’d call this once
        in the setup part of the script, before defining <code>f()</code>. This
        takes <i>a number of bins as an input</i> and it assumes
        <i>they are all the same size.</i>
        This will return a function that you will call inside of
        <code>f()</code>.
        <a
          href="https://github.com/TradeIdeasPhilip/random-svg-tests/blob/4b3583e48a336d21571e8974ca66e4b926baeb0e/src/utility.ts#L321"
          >Full documentation</a
        >.
      </li>
      <li>
        <code>support.lerpPoints()</code> &mdash;
        <code>support.lerpPoints({x: x1, y: y1}, {x: x2, y: y2}, t)</code> will
        return a point on the line connecting the two input points. If
        <code>t</code> is 0, <code>lerpPoints()</code> will return its first
        input. If <code>t</code> is 1, <code>lerpPoints()</code> will return its
        second input. For all other values of <code>t</code>,
        <code>lerpPoints()</code> will linearly interpolate to create a new
        point.
      </li>
      <li>
        <code>support.lerp()</code> &mdash; Linear interpolation.
        <code>lerp(at0, at1, 0)</code> → <code>at0</code>.
        <code>lerp(at0, at1, 1)</code> → <code>at1</code>. E.g.
        <code
          >const randomValue = lerp(lowestLegalValue, HighestLegalValue,
          Math.random());</code
        >.
      </li>
      <li>
        <code>support.makeLinear()</code> &mdash; A more powerful approach to
        linear interpolation. This function returns another function.
        <a
          href="https://tradeideasphilip.github.io/phil-lib/functions/misc.makeLinear.html"
          >Full documentation</a
        >.
      </li>
      <li>
        <code>support.random()</code> &mdash; Given a string to seed it, returns
        a random number generator. The new random number generator can be a drop
        in replacement for <code>Math.random()</code>. See it in use in the
        “Polygons and Stars” example.
        <a
          href="https://github.com/TradeIdeasPhilip/random-svg-tests/blob/0461f7d4bb724a7fd01b77e962a5b74ab95fd6d2/src/utility.ts#L194"
          >Full documentation</a
        >.
      </li>
      <li>
        <code>support.referencePath</code> &mdash; This describes the background
        image that I am drawing in light blue. Initially it is empty. You can
        set this in your one time initialization. If you don't, the software
        will run your function at multiple places and create this path for you.
        In either case, you can access the <code>referencePath</code> in the
        function. <code>support.referencePath.d</code> accesses the
        <a
          href="https://developer.mozilla.org/en-US/docs/Web/SVG/Reference/Attribute/d"
          >path string</a
        >. <code>support.referencePath.length</code> gives you the length of the
        path. <code>support.referencePath.getPoint()</code> gives you the x,y of
        the path at a given distance along the path.
      </li>
      <li>
        <code>support.samples</code> &mdash;
        <code>support.samples.hilbert[0]</code> ...
        <code>support.samples.hilbert[3]</code> and
        <code>support.samples.peanocurve[0]</code> ...
        <code>support.samples.peanocurve[2]</code> contain interesting path
        strings.
      </li>
      <li>
        <code>support.sampleCount</code> &mdash; How much detail to use when
        displaying the output. If you see pink and dark red lines, try using
        more samples. The current default of 200 is more than enough most of the
        time. But in the "Like share and subscribe" example I set this to 2000.
      </li>
      <li>
        <code>support.maxKeyframes</code> &mdash; If we have more than this many
        circles, combine some of them to make this many bins.
      </li>
    </ul>
    <h2><a id="examples"></a>Examples</h2>
    <div id="codeSamplesHolder"></div>
  </body>
</html>
