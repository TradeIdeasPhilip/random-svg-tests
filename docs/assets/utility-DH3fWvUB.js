import{m as i}from"./misc-BHUyxQfl.js";function h(r,t){const e=i.angleBetween(r,t);return r+e/2}function a(r){if(!(Number.isFinite(r)&&r>=0&&r<=1))throw new Error(`t should be between 0 and 1, inclusive. t == ${r}`)}function w(...r){r.forEach(n=>{if(!(n>=0&&n<Number.MAX_SAFE_INTEGER))throw new Error("wtf")});const t=i.sum(r);if(t==0)throw new Error("wtf");return n=>{a(n),n*=t;for(let s=0;s<r.length;s++){const o=r[s];if(n<=o)return n/=o,{t:n,index:s};n-=o}throw new Error("wtf")}}function d(r,t,e){const n=r+t+e,s=i.makeBoundedLinear(r/n,0,(r+t)/n,1);return c=>{a(c);const f=s(c)*t,u=Math.min(f|0,t-1),l=f-u;return a(l),{t:l,index:u}}}function p(r){const t=2/(r+1),e=1-t;return s=>e*s*s+t*s}class E{#t;constructor(t=60){if(i.assertFinite(t),t<1||t!=(t|0))throw new Error("wtf");this.#t=t,this.fromMSF=this.fromMSF.bind(this),this.fromString=this.fromString.bind(this),Object.freeze(this)}get framesPerSecond(){return this.#t}fromMSF(t,e,n){return(t*60+e)*this.#t+n}fromString(t){const e=/^([0-9]+):([0-9]+):([0-9]+)$/.exec(t);if(!e)throw new Error("wtf");const n=i.parseIntX(e[1]),s=i.parseIntX(e[2]),o=i.parseIntX(e[3]);if(n===void 0||s===void 0||o===void 0)throw new Error("wtf");return this.fromMSF(n,s,o)}}function b(r){const t=r*Math.PI;return(1-Math.cos(t))/2}export{E as G,h as a,a as b,p as c,d,b as e,w as m};
