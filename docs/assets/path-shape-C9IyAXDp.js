import{m as l}from"./misc-CLGTS8fC.js";function P(c,t,n){return new DOMPoint(c,t).matrixTransform(n)}function b(c,t,n){const e=c.width/c.height,s=t.width/t.height;let i,o;n==="meet"?e>s?(i=t.width/c.width,o=i):(o=t.height/c.height,i=o):e>s?(o=t.height/c.height,i=o):(i=t.width/c.width,o=i);const r=-c.x*i+(t.width-c.width*i)/2+t.x,a=-c.y*o+(t.height-c.height*o)/2+t.y;return new DOMMatrix().translate(r,a).scale(i,o)}function k(){{const c={x:-1,y:-1,width:2,height:2},t={x:0,y:0,height:244,width:325},n=b(c,t,"meet");console.log("Test 1 (meet, square to wider):",{testFrom:c,testTo:t,testMatrix:n.toJSON()}),[{x:c.x,y:c.y},{x:c.x+c.width,y:c.y},{x:c.x+c.width,y:c.y+c.height},{x:c.x,y:c.y+c.height}].forEach(({x:s,y:i})=>{const o=P(s,i,n);if(console.log({xFrom:s,yFrom:i,toPoint:{x:o.x,y:o.y}}),o.x<t.x||o.x>t.x+t.width||o.y<t.y||o.y>t.y+t.height)throw new Error(`Test 1 failed: Point (${o.x}, ${o.y}) is outside destination (${t.x}, ${t.y}, ${t.width}, ${t.height})`)})}{const c={x:-1,y:-1,width:2,height:2},t={x:0,y:0,height:325,width:244},n=b(c,t,"meet");console.log("Test 2 (meet, square to taller):",{testFrom:c,testTo:t,testMatrix:n.toJSON()}),[{x:c.x,y:c.y},{x:c.x+c.width,y:c.y},{x:c.x+c.width,y:c.y+c.height},{x:c.x,y:c.y+c.height}].forEach(({x:s,y:i})=>{const o=P(s,i,n);if(console.log({xFrom:s,yFrom:i,toPoint:{x:o.x,y:o.y}}),o.x<t.x||o.x>t.x+t.width||o.y<t.y||o.y>t.y+t.height)throw new Error(`Test 2 failed: Point (${o.x}, ${o.y}) is outside destination (${t.x}, ${t.y}, ${t.width}, ${t.height})`)})}{const c={x:-1,y:-1,width:2,height:2},t={x:0,y:0,height:244,width:325},n=b(c,t,"slice");console.log("Test 3 (slice, square to wider):",{testFrom:c,testTo:t,testMatrix:n.toJSON()}),[{x:c.x,y:c.y},{x:c.x+c.width,y:c.y},{x:c.x+c.width,y:c.y+c.height},{x:c.x,y:c.y+c.height}].forEach(({x:s,y:i})=>{const o=P(s,i,n);console.log({xFrom:s,yFrom:i,toPoint:{x:o.x,y:o.y}})})}console.log("All tests passed!")}k();const v=new Intl.NumberFormat("en-US",{maximumSignificantDigits:8,useGrouping:!1}).format;class M{constructor(t,n,e,s){this.x0=t,this.y0=n,this.x=e,this.y=s,l.assertFinite(t,n,e,s),this.asString=`L ${v(e)},${v(s)}`,this.outgoingAngle=this.incomingAngle=Math.atan2(s-n,e-t)}toJSON(){return{command:"L",x0:this.x0,y0:this.y0,x:this.x,y:this.y}}static relative(t,n,e,s){return new this(t,n,e+t,s+n)}incomingAngle;outgoingAngle;command="L";asString;translate(t,n){return new M(this.x0+t,this.y0+n,this.x+t,this.y+n)}toCubic(){return new C(this.x0,this.y0,l.lerp(this.x0,this.x,1/3),l.lerp(this.y0,this.y,1/3),l.lerp(this.x0,this.x,2/3),l.lerp(this.y0,this.y,2/3),this.x,this.y)}transform(t){const n=P(this.x,this.y,t),e=P(this.x0,this.y0,t);return new M(e.x,e.y,n.x,n.y)}}class E{constructor(t,n,e,s,i,o,r){this.x0=t,this.y0=n,this.x1=e,this.y1=s,this.x=i,this.y=o,this.creationInfo=r,l.assertFinite(t,n,e,s,i,o),this.asString=`Q ${v(e)},${v(s)} ${v(i)},${v(o)}`}static line(t,n,e,s,i){return new this(t,n,(t+e)/2,(n+s)/2,e,s,i)}static line4(t,n,e,s){return this.line(t,n,e,s,{source:"line"})}static line2(t,n){return this.line4(t.x,t.y,n.x,n.y)}static angles(t,n,e,s,i,o){l.assertFinite(t,n,e,s,i,o);const r=W({x0:t,y0:n,angle:e},{x0:s,y0:i,angle:o+Math.PI});return r?new this(t,n,r.x,r.y,s,i,{source:"angles",success:!0,angle:o,angle0:e}):this.line(t,n,s,i,{source:"angles",success:!1,angle:o,angle0:e})}newAngles(t,n){return t??=this.requestedIncomingAngle,n??=this.requestedOutgoingAngle,E.angles(this.x0,this.y0,t,this.x,this.y,n)}toJSON(){return{command:"Q",x0:this.x0,y0:this.y0,x1:this.x1,y1:this.y1,x:this.x,y:this.y,creationInfo:this.creationInfo}}static controlPoints(t,n,e,s,i,o){return new this(t,n,e,s,i,o,{source:"controlPoints"})}static relative(t,n,e,s,i,o){return this.controlPoints(t,n,e+t,s+n,i+t,o+n)}get incomingAngle(){return Math.atan2(this.y1-this.y0,this.x1-this.x0)}get outgoingAngle(){return Math.atan2(this.y-this.y1,this.x-this.x1)}get requestedIncomingAngle(){return this.creationInfo.source=="angles"?this.creationInfo.angle0:this.incomingAngle}get requestedOutgoingAngle(){return this.creationInfo.source=="angles"?this.creationInfo.angle:this.outgoingAngle}command="Q";asString;translate(t,n){return E.controlPoints(this.x0+t,this.y0+n,this.x1+t,this.y1+n,this.x+t,this.y+n)}transform(t){const n=P(this.x0,this.y0,t),e=P(this.x1,this.y1,t),s=P(this.x,this.y,t);return E.controlPoints(n.x,n.y,e.x,e.y,s.x,s.y)}toCubic(){return new C(this.x0,this.y0,l.lerp(this.x0,this.x1,2/3),l.lerp(this.y0,this.y1,2/3),l.lerp(this.x,this.x1,2/3),l.lerp(this.y,this.y1,2/3),this.x,this.y)}split(t){const{x:n,x0:e,x1:s,y:i,y0:o,y1:r}=this,a=e,g=o,d=(1-t)*e+t*s,x=(1-t)*o+t*r,h=(1-t)**2*e+2*(1-t)*t*s+t**2*n,y=(1-t)**2*o+2*(1-t)*t*r+t**2*i,f=E.controlPoints(a,g,d,x,h,y),m=h,$=y,A=(1-t)*s+t*n,I=(1-t)*r+t*i,X=n,R=i,J=E.controlPoints(m,$,A,I,X,R);return[f,J]}multiSplit(t){if(l.assertFinite(t),t<1||(t|0)!=t)throw new Error("wtf");const n=[];let e=this;for(;t>1;){const s=1/t;let i;[i,e]=e.split(s),n.push(i),t--}return n.push(e),n}}class C{constructor(t,n,e,s,i,o,r,a){this.x0=t,this.y0=n,this.x1=e,this.y1=s,this.x2=i,this.y2=o,this.x=r,this.y=a,l.assertFinite(t,n,e,s,i,o,r,a),this.asString=`C ${v(e)},${v(s)} ${v(i)},${v(o)} ${v(r)},${v(a)}`}reverse(){return new C(this.x,this.y,this.x2,this.y2,this.x1,this.y1,this.x0,this.y0)}static relative(t,n,e,s,i,o,r,a){return new this(t,n,e+t,s+n,i+t,o+n,r+t,a+n)}get incomingAngle(){return Math.atan2(this.y1-this.y0,this.x1-this.x0)}get outgoingAngle(){return Math.atan2(this.y-this.y2,this.x-this.x2)}command="C";asString;translate(t,n){return new C(this.x0+t,this.y0+n,this.x1+t,this.y1+n,this.x2+t,this.y2+n,this.x+t,this.y+n)}transform(t){const n=P(this.x0,this.y0,t),e=P(this.x1,this.y1,t),s=P(this.x2,this.y2,t),i=P(this.x,this.y,t);return new C(n.x,n.y,e.x,e.y,s.x,s.y,i.x,i.y)}toCubic(){return this}}class N{get commands(){return this.#t}addCommand(t){this.#t.push(t),this.#n=void 0}addCommands(t){return t.forEach(n=>this.addCommand(n)),this}static fromStrings(t){let n=t.join(" ");const e=[];let s;for(;n=n.replace(/^ */,""),n!="";){let i=L.exec(n);if(i){const o=l.parseFloatX(i[1]),r=l.parseFloatX(i[2]);if(o===void 0||r===void 0)throw console.error(i,o,r,this),new Error("wtf");s&&e.push(s),s=this.M(o,r),n=i[3];continue}if(s){if(i=q.exec(n),i){const o=l.parseFloatX(i[1]),r=l.parseFloatX(i[2]);if(o===void 0||r===void 0)throw console.error(i,o,r,this),new Error("wtf");s=s.L(o,r),n=i[3];continue}if(i=D.exec(n),i){const o=l.parseFloatX(i[1]),r=l.parseFloatX(i[2]),a=l.parseFloatX(i[3]),g=l.parseFloatX(i[4]);if(o===void 0||r===void 0||a===void 0||g===void 0)throw console.error(i,o,r,a,g,this),new Error("wtf");s=s.Q(o,r,a,g),n=i[5];continue}if(i=Q.exec(n),i){const o=l.parseFloatX(i[1]),r=l.parseFloatX(i[2]),a=l.parseFloatX(i[3]),g=l.parseFloatX(i[4]),d=l.parseFloatX(i[5]),x=l.parseFloatX(i[6]);if(o===void 0||r===void 0||a===void 0||g===void 0||d===void 0||x===void 0)throw console.error(i,o,r,a,g,d,x,this),new Error("wtf");s=s.C(o,r,a,g,d,x),n=i[7];continue}}throw console.error(n),new Error("wtf")}return s&&e.push(s),e}static M(t,n){const e=new N;return e.M(t,n),e}#t=[];get pathShape(){return new p(this.#t)}#n;M(t,n,e=NaN){return l.assertFinite(t,n),this.#n={x:t,y:n,outgoingAngle:e},this}previous(){return this.#n??this.#t.at(-1)}H(t){const n=this.previous();return this.addCommand(new M(n.x,n.y,t,n.y)),this}V(t){const n=this.previous();return this.addCommand(new M(n.x,n.y,n.x,t)),this}L(t,n){const e=this.previous();return this.addCommand(new M(e.x,e.y,t,n)),this}Q(t,n,e,s){const i=this.previous();return this.addCommand(E.controlPoints(i.x,i.y,t,n,e,s)),this}Q_HV(t,n){const e=this.previous();return this.Q(t,e.y,t,n)}Q_VH(t,n){const e=this.previous();return this.Q(e.x,n,t,n)}Q_angles(t,n,e,s){const i=this.previous();if(s??=i.outgoingAngle,s===void 0)throw new Error("wtf");return this.addCommand(E.angles(i.x,i.y,s,t,n,e)),this}C(t,n,e,s,i,o){const r=this.previous();return this.addCommand(new C(r.x,r.y,t,n,e,s,i,o)),this}circle(t,n,e="cw"){const s=this.previous(),i=s.x,o=s.y,r=Math.atan2(o-n,i-t),a=Math.hypot(o-n,i-t),g=e=="cw"?1:-1,d=r+Math.PI*2*g,x=l.makeLinear(0,r,1,d);function h(m){switch(m){case 0:case 1:return s;default:{const $=x(m),A=l.polarToRectangular(a,$);return{x:t+A.x,y:n+A.y}}}}function y(m){return h(m)}return this.addParametricPath(y,8),this}arc(t,n,e,s,i){const o=this.previous(),r=o.x,a=o.y;let g=l.positiveModulo(Math.atan2(a-n,r-t),Math.PI*2);const d=Math.hypot(a-n,r-t);let x=l.positiveModulo(Math.atan2(s-n,e-t),Math.PI*2);const h=Math.hypot(s-n,e-t);i=="cw"?g>x&&(x+=Math.PI*2):g<x&&(g+=Math.PI*2);const y=Math.abs(g-x),f=Math.ceil(y*1.17+1e-4),m=l.makeLinear(0,d,1,h),$=l.makeLinear(0,g,1,x);function A(I){switch(I){case 0:return o;case 1:return{x:e,y:s};default:{const X=l.polarToRectangular(m(I),$(I));return{x:t+X.x,y:n+X.y}}}}return this.addParametricPath(A,f)}addParametricPath(t,n){if(n<=0)throw new Error("wtf");const e=.01/n,s=l.initializedArray(n+1,o=>{const r=o/n,a=t(r),g=Y(t,r,e);return{t:r,point:a,direction:g}});return l.initializedArray(n,o=>({from:s[o],to:s[o+1]})).forEach(o=>{this.Q_angles(o.to.point.x,o.to.point.y,o.to.direction,o.from.direction)}),this}}function T(c,t,n){if(!(t>=0&&t<=1))throw new Error("Expected 0 ≤ t ≤ 1");const e=Math.max(0,t-n),s=c(e),i=Math.min(1,t+n),o=c(i),r=o.x-s.x,a=o.y-s.y;return r==0&&a==0?NaN:Math.atan2(a,r)}function Y(c,t,n){const e=T(c,t,n*2),s=T(c,t,n*1),i=e-s;return s-i}const F=" *",u="(-?[0-9]+\\.?[0-9]*(?:[eE][-+]?[0-9]+)?)",w="(?: *[, ] *|(?=-))",L=new RegExp(`^M${F}${u}${w}${u}(.*)$`),V=new RegExp(`^m${F}${u}${w}${u}(.*)$`),q=new RegExp(`^L${F}${u}${w}${u}(.*)$`),O=new RegExp(`^${w}${u}${w}${u}(.*)$`),j=new RegExp(`^l${F}${u}${w}${u}(.*)$`),z=new RegExp(`^h${F}${u}(.*)$`),B=new RegExp(`^v${F}${u}(.*)$`),D=new RegExp(`^Q${F}${u}${w}${u}${w}${u}${w}${u}(.*)$`),G=new RegExp(`^${w}${u}${w}${u}${w}${u}${w}${u}(.*)$`),H=new RegExp(`^q${F}${u}${w}${u}${w}${u}${w}${u}(.*)$`),Q=new RegExp(`^C${F}${u}${w}${u}${w}${u}${w}${u}${w}${u}${w}${u}(.*)$`),S=new RegExp(`^${w}${u}${w}${u}${w}${u}${w}${u}${w}${u}${w}${u}(.*)$`),U=new RegExp(`^c${F}${u}${w}${u}${w}${u}${w}${u}${w}${u}${w}${u}(.*)$`),Z=new RegExp("^[zZ](.*)$");class K extends Error{constructor(t,n){super(t),this.where=n}}class p{static fromString(t){const n=this.fromJson(t);if(n)return n;let e=t,s=null;const i=h=>new K(h,e),o=h=>{const y=l.parseFloatX(h);if(y===void 0)throw i(`Invalid number: "${h}"`);return y};let r=0,a=0;const g=[],d=h=>{g.push(h),r=h.x,a=h.y};let x;for(;e=e.replace(/^ */,""),e!="";){if(s=L.exec(e)){r=o(s[1]),a=o(s[2]),x={x0:r,y0:a},e=s[3];continue}if(s=V.exec(e)){for(r+=o(s[1]),a+=o(s[2]),x={x0:r,y0:a},e=s[3];s=O.exec(e);){const h=M.relative(r,a,o(s[1]),o(s[2]));d(h),e=s[3]}continue}if(!x)throw i("Must start with an M command.");if(s=Z.exec(e)){if(r!=x.x0||a!=x.y0){const h=new M(r,a,x.x0,x.y0);d(h)}e=s[1];continue}if(s=q.exec(e)){const h=o(s[1]),y=o(s[2]),f=new M(r,a,h,y);d(f),e=s[3];continue}if(s=j.exec(e)){for(;s;){const h=o(s[1]),y=o(s[2]),f=M.relative(r,a,h,y);d(f),e=s[3],s=O.exec(e)}continue}if(s=z.exec(e)){const h=o(s[1]),y=new M(r,a,r+h,a);d(y),e=s[2];continue}if(s=B.exec(e)){const h=o(s[1]),y=new M(r,a,r,a+h);d(y),e=s[2];continue}if(s=D.exec(e)){const h=o(s[1]),y=o(s[2]),f=o(s[3]),m=o(s[4]),$=E.controlPoints(r,a,h,y,f,m);d($),e=s[5];continue}if(s=H.exec(e)){for(;s;){const h=o(s[1]),y=o(s[2]),f=o(s[3]),m=o(s[4]),$=E.relative(r,a,h,y,f,m);d($),e=s[5],s=G.exec(e)}continue}if(s=Q.exec(e)){for(;s;){const h=o(s[1]),y=o(s[2]),f=o(s[3]),m=o(s[4]),$=o(s[5]),A=o(s[6]),I=new C(r,a,h,y,f,m,$,A);d(I),e=s[7],s=S.exec(e)}continue}if(s=U.exec(e)){for(;s;){const h=o(s[1]),y=o(s[2]),f=o(s[3]),m=o(s[4]),$=o(s[5]),A=o(s[6]),I=C.relative(r,a,h,y,f,m,$,A);d(I),e=s[7],s=S.exec(e)}continue}throw i("Confused.")}return new this(g)}static fromJson(t){try{const e=JSON.parse(t).commands.map(s=>{switch(s.command){case"C":{const{x0:i,y0:o,x1:r,y1:a,x2:g,y2:d,x,y:h}=s;return new C(i,o,r,a,g,d,x,h)}case"L":{const{x0:i,y0:o,x:r,y:a}=s;return new M(i,o,r,a)}case"Q":{const{x0:i,y0:o,x:r,y:a,creationInfo:g}=s;switch(g.source){case"angles":{const{angle0:d,angle:x}=g,h=E.angles(i,o,d,r,a,x);return(h.creationInfo.source!="angles"||h.creationInfo.success!=g.success)&&console.warn("different",s,h),h}case"controlPoints":{const{x1:d,y1:x}=s;return E.controlPoints(i,o,d,x,r,a)}case"line":return E.line4(i,o,r,a);default:throw new Error(`Unknown source: "${g.source}"`)}}default:throw new Error(`Unknown command: "${s.command}"`)}});return new p(e)}catch{return}}matchForMorph(t){const n=this.commands.map(r=>r.toCubic()),e=t.commands.map(r=>r.toCubic());if(n.length!=e.length){const{shorter:r,longer:a}=n.length<e.length?{shorter:n,longer:e}:{shorter:e,longer:n};if(r.length==0)throw new Error("can't morph something into nothing");const g=a.length/r.length,d=[];r.forEach((x,h)=>{const y=Math.round((h+1)*g);for(;d.length<y;)d.push(x)}),r.length=0,r.push(...d)}if(n.length!=e.length)throw new Error("wtf");function s(r){return p.cssifyPath(r.map(a=>new p([a]).rawPath).join())}const i=s(n),o=s(e);return[i,o]}commands;get endX(){return this.commands.at(-1)?.x}get endY(){return this.commands.at(-1)?.y}get startX(){return this.commands.at(0)?.x0}get startY(){return this.commands.at(0)?.y0}constructor(t){this.commands=[...t]}static cssifyPath(t){return`path('${t}')`}get cssPath(){return p.cssifyPath(this.rawPath)}makeElement(){const t=document.createElementNS("http://www.w3.org/2000/svg","path"),n=this.cssPath;if(t.style.d=n,t.style.d=="")throw console.error(n,t),new Error("wtf");return t}static needAnM(t,n){return n?!t||t.x!=n.x0||t.y!=n.y0:!1}get rawPath(){return this.splitOnMove().flatMap(t=>{const n=[`M ${v(t.startX)},${v(t.startY)}`];return t.commands.forEach(e=>n.push(e.asString)),t.startX==t.endX&&t.startY==t.endY&&n.push("Z"),n}).join(" ")}get cssPaths(){return this.splitOnMove().map(t=>t.cssPath)}get rawPaths(){return this.splitOnMove().map(t=>t.rawPath)}splitOnMove(){const t=[];let n=[];return this.commands.forEach(e=>{p.needAnM(n.at(-1),e)&&(n=[],t.push(n)),n.push(e)}),t.map(e=>new p(e))}static join(t){return new p(t.flatMap(({Δx:n,Δy:e,shape:s})=>s.translate(n,e).commands))}convertToCubics(){return new p(this.commands.map(t=>t.toCubic()))}translate(t,n){return new p(this.commands.map(e=>e.translate(t,n)))}transform(t){return new p(this.commands.map(n=>n.transform(t)))}static parametric(t,n){const e=t(0);return N.M(e.x,e.y).addParametricPath(t,n).pathShape}static fixAngleRounding(t){return t+400-400}static toDegrees(t){return Math.round(t*l.degreesPerRadian*100)/100}dump(){const t=this.commands.map((n,e)=>{const{x0:s,y0:i,x:o,y:r,incomingAngle:a,outgoingAngle:g,command:d}=n,x=document.createElementNS("http://www.w3.org/2000/svg","path");x.setAttribute("d",new p([n]).rawPath);const h=x.getTotalLength(),y=this.commands[e-1],m=p.needAnM(y,n)?{}:{difference:p.toDegrees(l.angleBetween(y.outgoingAngle,a))};return{x0:s,y0:i,x:o,y:r,incomingAngle:p.toDegrees(a),outgoingAngle:p.toDegrees(g),length:h,c:d,...m}});console.table(t),console.log(this.rawPath),console.log(JSON.stringify(this))}}function W(c,t){if(l.assertFinite(c.x0,c.y0,c.angle,t.x0,t.y0,t.angle),isNaN(c.angle)||isNaN(t.angle)||c.angle==t.angle)return;const n=Math.tan(c.angle),e=Math.tan(t.angle),s=Math.abs(n)*100>Number.MAX_SAFE_INTEGER,i=Math.abs(e)*100>Number.MAX_SAFE_INTEGER;if(s&&i)return;const o=Math.atan2(t.y0-c.y0,t.x0-c.x0),r=l.angleBetween(c.angle,o),a=l.angleBetween(t.angle,o);if(r==0||Math.abs(a)==Math.PI){if(Math.abs(r)==Math.PI||a==0)return;const x=(c.x0+t.x0)/2,h=(c.y0+t.y0)/2;return{x,y:h}}const g=Math.sign(r),d=Math.sign(a);if(!(g!=d||g==0)&&!(Math.abs(a)<=Math.abs(r)+l.radiansPerDegree))if(s||i){const x=s?c.x0:t.x0,h=s?{...t,slope:e}:{...c,slope:n},y=h.slope*(x-h.x0)+h.y0;return{x,y}}else{const x=(t.y0-e*t.x0-c.y0+n*c.x0)/(n-e),h=n*(x-c.x0)+c.y0;return{x,y:h}}}export{M as L,p as P,E as Q,K as a,N as b,b as p};
