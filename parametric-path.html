<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/moon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>√∑</title>
    <script type="module" src="/src/parametric-path.ts"></script>
  </head>
  <body>
    <h1>Function</h1>
    <p>
      What do you want to graph? Create a parametric function in JavaScript. For
      each input value <code>t</code>, between 0 and 1, return an object with
      <code>x</code> and <code>y</code> parameters, both numbers.
    </p>
    <div style="display: flex; flex-direction: column">
      <div>
        <code>function (t /* A value between 0 and 1, inclusive. */,</code>
      </div>
      <div>
        <code style="margin-left: 10ch">support) {</code>
      </div>
      <div>
        <code style="margin-left: 2ch">"use strict";</code>
      </div>
      <textarea
        id="source"
        style="
          margin-left: 1.66667rem;
          min-height: 5lh;
          height: 50vh;
          font-size: inherit;
          text-wrap: nowrap;
        "
        autocorrect="off"
        spellcheck="off"
      >
// Lissajous Curves
// Change this formula and hit the ‚ÄúGo‚Äù button to see something different.

const a = 1; // Amplitude in x-direction
const b = 1; // Amplitude in y-direction
const freqX = 3; // Frequency in x-direction
const freqY = 2; // Frequency in y-direction
const phase = Math.PI / 2; // Phase difference
const angle = t * 2 * Math.PI;
const x = a * Math.sin(freqX * angle + phase);
const y = b * Math.sin(freqY * angle);

// This works well with my approximations.
// There are only two inflection points and they are both in regions where the path is almost linear.</textarea
      >
      <div>
        <code style="margin-left: 2ch">return { x, y };</code>
      </div>
      <div><code>}</code></div>
    </div>
    <button id="go">Go</button>
    <h2>Precision</h2>
    <p>
      This software will make a path approximating your function. This software
      takes samples at n evenly spread values of t. At each t, this software
      will record the position of your function and its derivative. Each segment
      is made of a part of a parabola chosen to best match the samples at either
      end.
    </p>
    <p>
      If you plan to smoothly morph between two paths, make sure this parameter
      is the same when you create each path. The rest should work itself out
      automatically.
    </p>
    <div id="segmentCountHolder" class="has-slider">
      <span> Number of segments: </span>
      <input
        id="segmentCountInput"
        type="range"
        min="10"
        max="500"
        step="1"
        value="20"
      />
      <span id="segmentCountSpan"></span>
    </div>
    <h2>Inputs</h2>
    <div id="inputsGroup">
      <p>
        You can access these sliders from inside your code. The name of each
        slider is written next to it <code>in blue</code>. The samples will
        update immediately as you move the slider.
      </p>
      <div id="inputs"></div>
      <button>Add Another Input</button>
    </div>
    <div id="error"></div>
    <h2>Output Samples</h2>
    <p>
      The output from this program is a css path, a string. That path can be
      used a lot of different ways. Here are a few examples.
    </p>
    <svg
      id="filledSample"
      data-sample
      viewBox="0 0 100 10"
      xmlns="http://www.w3.org/2000/svg"
      preserveAspectRatio="xMidYMid slice"
      style="
        padding: 1.5em;
        overflow: visible;
        max-height: 30vh;
        border: thin lightblue solid;
      "
    >
      <path></path>
    </svg>
    <svg
      id="outlineSample"
      data-sample
      viewBox="0 0 100 10"
      xmlns="http://www.w3.org/2000/svg"
      preserveAspectRatio="xMidYMid slice"
      style="
        padding: 1.5em;
        overflow: visible;
        max-height: 30vh;
        border: thin lightgreen solid;
      "
    >
      <path></path>
    </svg>
    <svg
      id="chasingPathsSample"
      data-sample
      viewBox="0 0 100 10"
      xmlns="http://www.w3.org/2000/svg"
      preserveAspectRatio="xMidYMid slice"
      style="
        padding: 1.5em;
        overflow: visible;
        max-height: 30vh;
        border: thin lightgray solid;
      "
    >
      <path></path>
    </svg>
    <svg
      id="dancingAntsSample"
      data-sample
      viewBox="0 0 100 10"
      xmlns="http://www.w3.org/2000/svg"
      preserveAspectRatio="xMidYMid slice"
      style="
        padding: 1.5em;
        overflow: visible;
        max-height: 30vh;
        border: thin yellow solid;
      "
    >
      <path></path>
    </svg>
    <svg
      id="tauFollowingPathSample"
      data-sample
      viewBox="0 0 100 10"
      xmlns="http://www.w3.org/2000/svg"
      preserveAspectRatio="xMidYMid slice"
      style="
        padding: 1.5em;
        overflow: visible;
        max-height: 30vh;
        border: thin lightsalmon solid;
      "
    >
      <path></path>
      <text>ùúè</text>
      <text>œÄ</text>
      <text>‚Üí</text>
    </svg>
    <svg
      id="textPathSample"
      data-sample
      viewBox="0 0 100 10"
      xmlns="http://www.w3.org/2000/svg"
      preserveAspectRatio="xMidYMid slice"
      style="
        padding: 1.5em;
        overflow: visible;
        max-height: 30vh;
        border: thin deeppink solid;
      "
    >
      <path id="forTextPathSample"></path>
      <text>
        <textPath href="#forTextPathSample">
          Quantitas Materi√¶ est mensura ejusdem orta ex illius Densitate et
          Magnitudine conjunctim. Corpus omne, quod ex partibus ejusdem
          conditionis constat, dicitur homogeneum; si ex diversis, heterogeneum.
        </textPath>
      </text>
    </svg>
    <div>
      <p>
        I have provided one demo using
        <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/clip-path"
          >style.clipPath</a
        >. <code>style.clipPath</code> is a very powerful tool. However, I
        usually prefer to work with a mask instead of a clipPath. I get a
        superset of the abilities with a lot less drama.
      </p>
      <p>
        I have provided two demos using
        <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/mask-image"
          >style.maskImage</a
        >. The first is a pointer to a live <code>&lt;mask&gt;</code> in a live
        <code>&lt;svg&gt;</code>. This gives incredible control. The second is a
        data-url. You can create the data-url in advance and use it without any
        JavaScript. You can use a variety of
        <code>style.mask-*</code> properties to customize this mask.
      </p>
    </div>
    <svg
      id="clipAndMaskSupport"
      data-sample
      viewBox="0 0 100 10"
      xmlns="http://www.w3.org/2000/svg"
      preserveAspectRatio="xMidYMid slice"
      style="
        padding: 1.5em;
        overflow: visible;
        max-height: 30vh;
        border: thin peachpuff solid;
      "
    >
      <defs>
        <mask
          id="path-to-mask"
          maskContentUnits="userSpaceOnUse"
          maskUnits="objectBoundingBox"
          style="mask-type: alpha"
        >
          <path
            data-skip-auto-fill
            fill="white"
            stroke="white"
            stroke-width="0.1"
            fill-opacity="0.5"
          ></path>
        </mask>
      </defs>
      <path stroke="red" fill-opacity="0.5" fill="black"></path>
    </svg>
    <img
      id="clipPathSample"
      src="./Encinitas_colorful_night.jpg"
      alt="A bright and colorful photo including the colors of sunset.  It looks slightly unreal because I used ‚ÄúNight Sight‚Äù mode on my Android camera."
      style="max-height: 30vh"
    />
    <img
      id="maskSample"
      src="./Encinitas_colorful_night.jpg"
      alt="A bright and colorful photo including the colors of sunset.  It looks slightly unreal because I used ‚ÄúNight Sight‚Äù mode on my Android camera."
      style="
        max-height: 30vh;
        mask-image: url(#path-to-mask);
        mask-size: contain;
      "
    />

    <img
      id="maskSample2"
      src="./Encinitas_colorful_night.jpg"
      alt="A bright and colorful photo including the colors of sunset.  It looks slightly unreal because I used ‚ÄúNight Sight‚Äù mode on my Android camera."
      style="max-height: 30vh"
    />

    <div id="resultHolder">
      <code id="result">&lt;path /&gt;</code>
    </div>

    <h1>Code Samples</h1>

    <p>These are some ideas to get you started.</p>

    <div id="codeSamplesHolder">
      <div>
        <div data-description>
          <button class="show-this">Show This</button>Simple Ellipse
        </div>
        <pre data-code-snippet>
// The height can be anything convenient to you.
// This software will automatically zoom and pan to show off your work.
const height = 1;
// Use the first slider to change the width of the ellipse.
const width = height * support.input(0) * 2;
// Use the second slider to change the starting point on the ellipse.
// This doesn't matter in a static ellipse, but it can be important in some animations and other special cases.
const angle = (t + support.input(1)) * 2 * Math.PI;
const x = width * Math.cos(angle);
const y = height * Math.sin(angle);</pre
        >
      </div>
      <div>
        <div data-description>
          <button class="show-this">Show This</button>Circle with Wavy Edge
        </div>
        <pre data-code-snippet>
// Make sure you use enough segments.
// This includes a lot of inflection points, which means you need a lot of segments.
const height = 1;
const width = height;
const angle = t * 2 * Math.PI;
const adjustmentAngle = angle * 8;
const adjustmentFactor = Math.sin(adjustmentAngle)/10+1;
const x = width * Math.cos(angle) * adjustmentFactor;
const y = height * Math.sin(angle) * adjustmentFactor;</pre
        >
      </div>
      <div>
        <div data-description>
          <button class="show-this">Show This</button>Lissajous Curves
        </div>
        <pre data-code-snippet>
const a = 1; // Amplitude in x-direction
const b = 1; // Amplitude in y-direction
const freqX = 3; // Frequency in x-direction
const freqY = 2; // Frequency in y-direction
const phase = Math.PI / 2; // Phase difference
const angle = t * 2 * Math.PI;
const x = a * Math.sin(freqX * angle + phase);
const y = b * Math.sin(freqY * angle);

// This works well with my approximations.
// There are only two inflection points and they are both in regions where the path is almost linear.</pre
        >
      </div>
      <div>
        <div data-description>
          <button class="show-this">Show This</button>Hypocycloid / Astroid
        </div>
        <pre data-code-snippet>
const R = 1; // Radius of the large circle
const r = R / 4; // Radius of the small circle (astroid case)
const angle = t * 2 * Math.PI;
const x = (R - r) * Math.cos(angle) + r * Math.cos((R - r) / r * angle);
const y = (R - r) * Math.sin(angle) - r * Math.sin((R - r) / r * angle);

// The sharp corners in this curve push my model to its limits.
// However, it does a decent job as long as you use enough segments.</pre
        >
      </div>
      <div>
        <div data-description>
          <button class="show-this">Show This</button>Bell Curve
        </div>
        <pre data-code-snippet>
// Number of standard deviations in each direction:
const right = support.input(0) * 5;
const left = - right;
const width = right - left;
const x = t * width + left;
const height = support.input(1) * 4 + 1;
// Negate this.
// This program works with normal graphics notation where lower values of y are higher on the display.
// Normal algebra-class graphs show lower values of y lower on the screen.
const y = - height * Math.exp(-x*x);</pre
        >
      </div>
      <div>
        <div data-description>
          <button class="show-this">Show This</button>Spirograph Curve (‚üü)
        </div>
        <pre data-code-snippet>
// Spirograph Curve (‚üü) - A general Spirograph pattern with adjustable parameters
// Sliders: rolling circle radius (‚üü), pen distance (‚ü†), number of turns (‚ü°)
const R = 1.0; // Fixed circle radius
const r = support.input(0) * 2 - 1; // Rolling circle radius: -1 to 1 (‚üü). Negative for inside, positive for outside
const d = support.input(1) * 2; // Pen distance from rolling circle center: 0 to 2 (‚ü†)
const numTurns = support.input(2) * 10; // Number of turns: 0 to 10 (‚ü°)
const angle = t * 2 * Math.PI * numTurns;

// Determine if rolling inside (hypotrochoid) or outside (epitrochoid)
const k = r &lt; 0 ? (R - r) / r : (R + r) / r; // Frequency ratio
const baseRadius = r &lt; 0 ? (R - r) : (R + r); // Base radius for the rolling circle's center

// Parametric equations
const x = baseRadius * Math.cos(angle) + (r &lt; 0 ? d : -d) * Math.cos(k * angle);
const y = baseRadius * Math.sin(angle) - (r &lt; 0 ? d : -d) * Math.sin(k * angle);</pre
        >
      </div>
      <div>
        <div data-description>
          <button class="show-this">Show This</button>Archimedean Spiral with
          Oscillation
        </div>
        <pre data-code-snippet>
const scale = 1; // Overall scale of the spiral
const turns = 3; // Number of full rotations
const waveFreq = 10; // Frequency of the oscillation
const waveAmp = 0.1; // Amplitude of the oscillation
const angle = t * 2 * Math.PI * turns;
const radius = scale * t; // Linear growth for Archimedean spiral
const wave = waveAmp * Math.sin(t * 2 * Math.PI * waveFreq);
const x = radius * Math.cos(angle) * (1 + wave);
const y = radius * Math.sin(angle) * (1 + wave);</pre
        >
      </div>
      <div>
        <div data-description>
          <button class="show-this">Show This</button>Heart Curve
        </div>
        <pre data-code-snippet>
const scale = 1;
const angle = t * 2 * Math.PI;
const x = scale * (16 * Math.pow(Math.sin(angle), 3));
const algebraClassY = scale * (13 * Math.cos(angle) - 5 * Math.cos(2 * angle) - 2 * Math.cos(3 * angle) - Math.cos(4 * angle));
const y = - algebraClassY;
</pre
        >
      </div>
      <div>
        <div data-description>
          <button class="show-this">Show This</button>Butterfly Curve
        </div>
        <pre data-code-snippet>
const scale = 0.2;
const angle = t * 24 * Math.PI * support.input(0); // More rotations for complexity
const e = Math.exp(1);
const x = scale * Math.sin(angle) * (e ** Math.cos(angle) - 2 * Math.cos(4 * angle) - Math.pow(Math.sin(angle / 12), 5));
const y = scale * Math.cos(angle) * (e ** Math.cos(angle) - 2 * Math.cos(4 * angle) - Math.pow(Math.sin(angle / 12), 5));

// This will require a lot of segments to display correctly.</pre
        >
      </div>
      <div>
        <div data-description>
          <button class="show-this">Show This</button>Hollow Star ‚òÜ
        </div>
        <pre data-code-snippet>
const scale = 1; // Overall scale of the star
const points = 5; // Number of star points
const innerRadius = 0.4; // Radius of the inner points (controls star shape)
const roundness = 0.1; // Amplitude of the oscillation for rounding
const angle = t * 2 * Math.PI; // Full circle
const starAngle = angle * points; // Angle scaled for 5 points
const radius = scale * (1 - innerRadius * (Math.cos(starAngle) + 1) / 2); // Base star shape
const rounding = roundness * Math.sin(starAngle); // Oscillation for rounding
const x = (radius + rounding) * Math.cos(angle);
const y = (radius + rounding) * Math.sin(angle);

// According to Wikipedia, if it's hollow inside, it's a star.
// If you can see the lines crossing each other, it's a pentagram.</pre
        >
      </div>
      <div>
        <div data-description>
          <button class="show-this">Show This</button>Rotating Ellipse
        </div>
        <pre data-code-snippet>
const r1 = 0.5; // Short radius of the ellipse
const r2 = 1.0; // Long radius of the ellipse
const phase = support.input(0) * Math.PI; // First slider: Rotation angle in radians (0 to œÄ)
const angle = t * 2 * Math.PI; // Full circle

// Basic ellipse centered at the origin
const xEllipse = r1 * Math.cos(angle);
const yEllipse = r2 * Math.sin(angle);

// Rotate the ellipse by the phase angle
const x = xEllipse * Math.cos(phase) - yEllipse * Math.sin(phase);
const y = xEllipse * Math.sin(phase) + yEllipse * Math.cos(phase);

// I used this formula as a starting place for the rounded pentagram.</pre
        >
      </div>
      <div>
        <div data-description>
          <button class="show-this">Show This</button>Rounded Pentagram ‚õ§,
          Heptagram, etc.
        </div>
        <pre data-code-snippet>
const r1 = 0.5 * support.input(0); // Short radius of the ellipse. Top slider will adjust it.
const r2 = 1.0; // Long radius of the ellipse
const phase = Math.PI * t; // The reference ellipse will make one half complete rotation during the tracing process.
const numberOfTrips = support.input(1) * 10;  // Effective range is 0 to 10 
const angle = t * 2 * Math.PI * numberOfTrips; // Basic ellipse centered at the origin
const xEllipse = r1 * Math.cos(angle);
const yEllipse = r2 * Math.sin(angle);// Rotate the ellipse by the phase angle
const x = xEllipse * Math.cos(phase) - yEllipse * Math.sin(phase);
const y = xEllipse * Math.sin(phase) + yEllipse * Math.cos(phase);

// The top slider controls the amount of curvature in the output.
// The second slider controls the number of lobes.
// Try values like 0.05, 0.15, 0.25, ‚Ä¶, 0.95 for closed shapes.</pre
        >
      </div>
      <div>
        <div data-description>
          <button class="show-this">Show This</button>Cardioid with Nodal Loops
          (‡§ï‚ãè)
        </div>
        <pre data-code-snippet>
// Cardioid with Nodal Loops (‡§ï‚ãè) - A heart-shaped curve with adjustable loops
// Slider adjusts the number of nodal loops (‚ã∞)
const r = 0.5; // Radius of the base circles for the cardioid
const nodalFreq = Math.round(support.input(0) * 10); // Frequency of nodal loops (‚ã∞). First slider: 0 to 10
const nodalAmp = 0.1; // Amplitude of the nodal loops
const angle = t * 2 * Math.PI; // Full circle

// Base cardioid: point on a circle rolling around another circle
const xCardioid = r * (2 * Math.cos(angle) - Math.cos(2 * angle));
const yCardioid = r * (2 * Math.sin(angle) - Math.sin(2 * angle));

// Add nodal loops along the curve
const nodalOffset = nodalAmp * Math.sin(nodalFreq * angle);
const x = xCardioid + nodalOffset * Math.cos(angle);
const y = yCardioid + nodalOffset * Math.sin(angle);</pre
        >
      </div>

      <div>
        <div data-description>
          <button class="show-this">Show This</button>Lissajous ≈öpiral (‡§∂)
        </div>
        <pre data-code-snippet>
// Lissajous ≈öpiral (‡§∂) - A spiraling Lissajous curve with adjustable frequency
// Slider adjusts the frequency ratio (‚üê)
const scale = 1.0; // Base scale of the curve
const freqRatio = 1 + support.input(0) * 4; // Frequency ratio x:y (‚üê). First slider: 1 to 5
const spiralFactor = t; // Linearly increasing amplitude for spiral effect
const angle = t * 2 * Math.PI; // Full circle

// Lissajous curve with spiraling amplitude
const x = scale * spiralFactor * Math.cos(angle);
const y = scale * spiralFactor * Math.sin(freqRatio * angle);</pre
        >
      </div>
    </div>
    <h1>More Information</h1>
    <p>
      Desmos can draw your equations very well. But what if you want to display
      your results somewhere else? A path can be used in so many places so you
      can integrate your results with a bigger project. This code's been around
      for a while, but I just built this user interface to let you poke around
      without any serious programming.
    </p>
    <p>
      <a href="https://youtu.be/aJKVHNAOACU">This video</a> will show you how to
      use this page, and it will discuss the origins of this page and this
      project. You can find general information about this project
      <a href="https://github.com/TradeIdeasPhilip/random-svg-tests/tree/master"
        >here</a
      >.
    </p>
  </body>
</html>
