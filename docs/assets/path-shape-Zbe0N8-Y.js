import{m as h}from"./misc-CLGTS8fC.js";const y=new Intl.NumberFormat("en-US",{maximumSignificantDigits:8}).format;class M{constructor(t,n,s,e){this.x0=t,this.y0=n,this.x=s,this.y=e,h.assertFinite(t,n,s,e),this.asString=`L ${y(s)},${y(e)}`,this.outgoingAngle=this.incomingAngle=Math.atan2(e-n,s-t)}toJSON(){return{command:"L",x0:this.x0,y0:this.y0,x:this.x,y:this.y}}static relative(t,n,s,e){return new this(t,n,s+t,e+n)}incomingAngle;outgoingAngle;command="L";asString;translate(t,n){return new M(this.x0+t,this.y0+n,this.x+t,this.y+n)}toCubic(){return new C(this.x0,this.y0,h.lerp(this.x0,this.x,1/3),h.lerp(this.y0,this.y,1/3),h.lerp(this.x0,this.x,2/3),h.lerp(this.y0,this.y,2/3),this.x,this.y)}}class E{constructor(t,n,s,e,i,o,r){this.x0=t,this.y0=n,this.x1=s,this.y1=e,this.x=i,this.y=o,this.creationInfo=r,h.assertFinite(t,n,s,e,i,o),this.asString=`Q ${y(s)},${y(e)} ${y(i)},${y(o)}`}static line(t,n,s,e,i){return new this(t,n,(t+s)/2,(n+e)/2,s,e,i)}static line4(t,n,s,e){return this.line(t,n,s,e,{source:"line"})}static line2(t,n){return this.line4(t.x,t.y,n.x,n.y)}static angles(t,n,s,e,i,o){h.assertFinite(t,n,s,e,i,o);const r=U({x0:t,y0:n,angle:s},{x0:e,y0:i,angle:o+Math.PI});return r?new this(t,n,r.x,r.y,e,i,{source:"angles",success:!0,angle:o,angle0:s}):this.line(t,n,e,i,{source:"angles",success:!1,angle:o,angle0:s})}newAngles(t,n){return t??=this.requestedIncomingAngle,n??=this.requestedOutgoingAngle,E.angles(this.x0,this.y0,t,this.x,this.y,n)}toJSON(){return{command:"Q",x0:this.x0,y0:this.y0,x1:this.x1,y1:this.y1,x:this.x,y:this.y,creationInfo:this.creationInfo}}static controlPoints(t,n,s,e,i,o){return new this(t,n,s,e,i,o,{source:"controlPoints"})}static relative(t,n,s,e,i,o){return this.controlPoints(t,n,s+t,e+n,i+t,o+n)}get incomingAngle(){return Math.atan2(this.y1-this.y0,this.x1-this.x0)}get outgoingAngle(){return Math.atan2(this.y-this.y1,this.x-this.x1)}get requestedIncomingAngle(){return this.creationInfo.source=="angles"?this.creationInfo.angle0:this.incomingAngle}get requestedOutgoingAngle(){return this.creationInfo.source=="angles"?this.creationInfo.angle:this.outgoingAngle}command="Q";asString;translate(t,n){return E.controlPoints(this.x0+t,this.y0+n,this.x1+t,this.y1+n,this.x+t,this.y+n)}toCubic(){return new C(this.x0,this.y0,h.lerp(this.x0,this.x1,2/3),h.lerp(this.y0,this.y1,2/3),h.lerp(this.x,this.x1,2/3),h.lerp(this.y,this.y1,2/3),this.x,this.y)}}class C{constructor(t,n,s,e,i,o,r,c){this.x0=t,this.y0=n,this.x1=s,this.y1=e,this.x2=i,this.y2=o,this.x=r,this.y=c,h.assertFinite(t,n,s,e,i,o,r,c),this.asString=`C ${y(s)},${y(e)} ${y(i)},${y(o)} ${y(r)},${y(c)}`}reverse(){return new C(this.x,this.y,this.x2,this.y2,this.x1,this.y1,this.x0,this.y0)}static relative(t,n,s,e,i,o,r,c){return new this(t,n,s+t,e+n,i+t,o+n,r+t,c+n)}get incomingAngle(){return Math.atan2(this.y1-this.y0,this.x1-this.x0)}get outgoingAngle(){return Math.atan2(this.y-this.y2,this.x-this.x2)}command="C";asString;translate(t,n){return new C(this.x0+t,this.y0+n,this.x1+t,this.y1+n,this.x2+t,this.y2+n,this.x+t,this.y+n)}toCubic(){return this}}class X{get commands(){return this.#t}addCommand(t){this.#t.push(t),this.#n=void 0}addCommands(t){return t.forEach(n=>this.addCommand(n)),this}static fromStrings(t){let n=t.join(" ");const s=[];let e;for(;n=n.replace(/^ */,""),n!="";){let i=L.exec(n);if(i){const o=h.parseFloatX(i[1]),r=h.parseFloatX(i[2]);if(o===void 0||r===void 0)throw console.error(i,o,r,this),new Error("wtf");e&&s.push(e),e=this.M(o,r),n=i[3];continue}if(e){if(i=Q.exec(n),i){const o=h.parseFloatX(i[1]),r=h.parseFloatX(i[2]);if(o===void 0||r===void 0)throw console.error(i,o,r,this),new Error("wtf");e=e.L(o,r),n=i[3];continue}if(i=O.exec(n),i){const o=h.parseFloatX(i[1]),r=h.parseFloatX(i[2]),c=h.parseFloatX(i[3]),g=h.parseFloatX(i[4]);if(o===void 0||r===void 0||c===void 0||g===void 0)throw console.error(i,o,r,c,g,this),new Error("wtf");e=e.Q(o,r,c,g),n=i[5];continue}if(i=T.exec(n),i){const o=h.parseFloatX(i[1]),r=h.parseFloatX(i[2]),c=h.parseFloatX(i[3]),g=h.parseFloatX(i[4]),m=h.parseFloatX(i[5]),l=h.parseFloatX(i[6]);if(o===void 0||r===void 0||c===void 0||g===void 0||m===void 0||l===void 0)throw console.error(i,o,r,c,g,m,l,this),new Error("wtf");e=e.C(o,r,c,g,m,l),n=i[7];continue}}throw console.error(n),new Error("wtf")}return e&&s.push(e),s}static M(t,n){const s=new X;return s.M(t,n),s}#t=[];get pathShape(){return new x(this.#t)}#n;M(t,n,s=NaN){return h.assertFinite(t,n),this.#n={x:t,y:n,outgoingAngle:s},this}previous(){return this.#n??this.#t.at(-1)}H(t){const n=this.previous();return this.addCommand(new M(n.x,n.y,t,n.y)),this}V(t){const n=this.previous();return this.addCommand(new M(n.x,n.y,n.x,t)),this}L(t,n){const s=this.previous();return this.addCommand(new M(s.x,s.y,t,n)),this}Q(t,n,s,e){const i=this.previous();return this.addCommand(E.controlPoints(i.x,i.y,t,n,s,e)),this}Q_HV(t,n){const s=this.previous();return this.Q(t,s.y,t,n)}Q_VH(t,n){const s=this.previous();return this.Q(s.x,n,t,n)}Q_angles(t,n,s,e){const i=this.previous();if(e??=i.outgoingAngle,e===void 0)throw new Error("wtf");return this.addCommand(E.angles(i.x,i.y,e,t,n,s)),this}C(t,n,s,e,i,o){const r=this.previous();return this.addCommand(new C(r.x,r.y,t,n,s,e,i,o)),this}circle(t,n,s="cw"){const e=this.previous(),i=e.x,o=e.y,r=Math.atan2(o-n,i-t),c=Math.hypot(o-n,i-t),g=s=="cw"?1:-1,m=r+Math.PI*2*g,l=h.makeLinear(0,r,1,m);function a(p){switch(p){case 0:case 1:return e;default:{const v=l(p),F=h.polarToRectangular(c,v);return{x:t+F.x,y:n+F.y}}}}function f(p){return a(p)}return this.addParametricPath(f,8),this}arc(t,n,s,e,i){const o=this.previous(),r=o.x,c=o.y;let g=h.positiveModulo(Math.atan2(c-n,r-t),Math.PI*2);const m=Math.hypot(c-n,r-t);let l=h.positiveModulo(Math.atan2(e-n,s-t),Math.PI*2);const a=Math.hypot(e-n,s-t);i=="cw"?g>l&&(l+=Math.PI*2):g<l&&(g+=Math.PI*2);const f=Math.abs(g-l),$=Math.ceil(f*1.17+1e-4),p=h.makeLinear(0,m,1,a),v=h.makeLinear(0,g,1,l);function F(P){switch(P){case 0:return o;case 1:return{x:s,y:e};default:{const R=h.polarToRectangular(p(P),v(P));return{x:t+R.x,y:n+R.y}}}}return this.addParametricPath(F,$)}addParametricPath(t,n){if(n<=0)throw new Error("wtf");const s=.01/n,e=h.initializedArray(n+1,o=>{const r=o/n,c=t(r),g=S(t,r,s);return{t:r,point:c,direction:g}});return h.initializedArray(n,o=>({from:e[o],to:e[o+1]})).forEach(o=>{this.Q_angles(o.to.point.x,o.to.point.y,o.to.direction,o.from.direction)}),this}}function I(w,t,n){if(!(t>=0&&t<=1))throw new Error("Expected 0 ≤ t ≤ 1");const s=Math.max(0,t-n),e=w(s),i=Math.min(1,t+n),o=w(i),r=o.x-e.x,c=o.y-e.y;return r==0&&c==0?NaN:Math.atan2(c,r)}function S(w,t,n){const s=n*2,e=n,i=I(w,t,s),o=I(w,t,e),r=i-o,c=o-r;return console.table([{type:"ε×1",offset:e,result:o},{type:"ε×2",offset:s,result:i},{type:"ε×0",offset:0,result:c}]),c}const A=" *",u="(-?[0-9]+\\.?[0-9]*)",d="(?: *[, ] *|(?=-))",L=new RegExp(`^M${A}${u}${d}${u}(.*)$`),k=new RegExp(`^m${A}${u}${d}${u}(.*)$`),Q=new RegExp(`^L${A}${u}${d}${u}(.*)$`),b=new RegExp(`^${d}${u}${d}${u}(.*)$`),D=new RegExp(`^l${A}${u}${d}${u}(.*)$`),q=new RegExp(`^h${A}${u}(.*)$`),J=new RegExp(`^v${A}${u}(.*)$`),O=new RegExp(`^Q${A}${u}${d}${u}${d}${u}${d}${u}(.*)$`),V=new RegExp(`^${d}${u}${d}${u}${d}${u}${d}${u}(.*)$`),j=new RegExp(`^q${A}${u}${d}${u}${d}${u}${d}${u}(.*)$`),T=new RegExp(`^C${A}${u}${d}${u}${d}${u}${d}${u}${d}${u}${d}${u}(.*)$`),N=new RegExp(`^${d}${u}${d}${u}${d}${u}${d}${u}${d}${u}${d}${u}(.*)$`),z=new RegExp(`^c${A}${u}${d}${u}${d}${u}${d}${u}${d}${u}${d}${u}(.*)$`),B=new RegExp("^[zZ](.*)$");class H extends Error{constructor(t,n){super(t),this.where=n}}class x{static fromString(t){const n=this.fromJson(t);if(n)return n;let s=t,e=null;const i=a=>new H(a,s),o=a=>{const f=h.parseFloatX(a);if(f===void 0)throw i(`Invalid number: "${a}"`);return f};let r=0,c=0;const g=[],m=a=>{g.push(a),r=a.x,c=a.y};let l;for(;s=s.replace(/^ */,""),s!="";){if(e=L.exec(s)){r=o(e[1]),c=o(e[2]),l={x0:r,y0:c},s=e[3];continue}if(e=k.exec(s)){for(r+=o(e[1]),c+=o(e[2]),l={x0:r,y0:c},s=e[3];e=b.exec(s);){const a=M.relative(r,c,o(e[1]),o(e[2]));m(a),s=e[3]}continue}if(!l)throw i("Must start with an M command.");if(e=B.exec(s)){if(r!=l.x0||c!=l.y0){const a=new M(r,c,l.x0,l.y0);m(a)}s=e[1];continue}if(e=Q.exec(s)){const a=o(e[1]),f=o(e[2]),$=new M(r,c,a,f);m($),s=e[3];continue}if(e=D.exec(s)){for(;e;){const a=o(e[1]),f=o(e[2]),$=M.relative(r,c,a,f);m($),s=e[3],e=b.exec(s)}continue}if(e=q.exec(s)){const a=o(e[1]),f=new M(r,c,r+a,c);m(f),s=e[2];continue}if(e=J.exec(s)){const a=o(e[1]),f=new M(r,c,r,c+a);m(f),s=e[2];continue}if(e=O.exec(s)){const a=o(e[1]),f=o(e[2]),$=o(e[3]),p=o(e[4]),v=E.controlPoints(r,c,a,f,$,p);m(v),s=e[5];continue}if(e=j.exec(s)){for(;e;){const a=o(e[1]),f=o(e[2]),$=o(e[3]),p=o(e[4]),v=E.relative(r,c,a,f,$,p);m(v),s=e[5],e=V.exec(s)}continue}if(e=T.exec(s)){for(;e;){const a=o(e[1]),f=o(e[2]),$=o(e[3]),p=o(e[4]),v=o(e[5]),F=o(e[6]),P=new C(r,c,a,f,$,p,v,F);m(P),s=e[7],e=N.exec(s)}continue}if(e=z.exec(s)){for(;e;){const a=o(e[1]),f=o(e[2]),$=o(e[3]),p=o(e[4]),v=o(e[5]),F=o(e[6]),P=C.relative(r,c,a,f,$,p,v,F);m(P),s=e[7],e=N.exec(s)}continue}throw i("Confused.")}return new this(g)}static fromJson(t){try{const s=JSON.parse(t).commands.map(e=>{switch(e.command){case"C":{const{x0:i,y0:o,x1:r,y1:c,x2:g,y2:m,x:l,y:a}=e;return new C(i,o,r,c,g,m,l,a)}case"L":{const{x0:i,y0:o,x:r,y:c}=e;return new M(i,o,r,c)}case"Q":{const{x0:i,y0:o,x:r,y:c,creationInfo:g}=e;switch(g.source){case"angles":{const{angle0:m,angle:l}=g,a=E.angles(i,o,m,r,c,l);return(a.creationInfo.source!="angles"||a.creationInfo.success!=g.success)&&console.warn("different",e,a),a}case"controlPoints":{const{x1:m,y1:l}=e;return E.controlPoints(i,o,m,l,r,c)}case"line":return E.line4(i,o,r,c);default:throw new Error(`Unknown source: "${g.source}"`)}}default:throw new Error(`Unknown command: "${e.command}"`)}});return new x(s)}catch{return}}matchForMorph(t){const n=this.commands.map(r=>r.toCubic()),s=t.commands.map(r=>r.toCubic());if(n.length!=s.length){const{shorter:r,longer:c}=n.length<s.length?{shorter:n,longer:s}:{shorter:s,longer:n};if(r.length==0)throw new Error("can't morph something into nothing");const g=c.length/r.length,m=[];r.forEach((l,a)=>{const f=Math.round((a+1)*g);for(;m.length<f;)m.push(l)}),r.length=0,r.push(...m)}if(n.length!=s.length)throw new Error("wtf");function e(r){return x.cssifyPath(r.map(c=>new x([c]).rawPath).join())}const i=e(n),o=e(s);return[i,o]}commands;get endX(){return this.commands.at(-1)?.x}get endY(){return this.commands.at(-1)?.y}get startX(){return this.commands.at(0)?.x0}get startY(){return this.commands.at(0)?.y0}constructor(t){this.commands=[...t]}static cssifyPath(t){return`path('${t}')`}get cssPath(){return x.cssifyPath(this.rawPath)}makeElement(){const t=document.createElementNS("http://www.w3.org/2000/svg","path"),n=this.cssPath;if(t.style.d=n,t.style.d=="")throw console.error(n,t),new Error("wtf");return t}static needAnM(t,n){return n?!t||t.x!=n.x0||t.y!=n.y0:!1}get rawPath(){return this.commands.flatMap((t,n)=>{const s=[],e=this.commands[n-1];return x.needAnM(e,t)&&s.push(`M ${y(t.x0)},${y(t.y0)}`),s.push(t.asString),s}).join(" ")}get cssPaths(){return this.splitOnMove().map(t=>t.cssPath)}get rawPaths(){return this.splitOnMove().map(t=>t.rawPath)}splitOnMove(){const t=[];let n=[];return this.commands.forEach(s=>{x.needAnM(n.at(-1),s)&&(n=[],t.push(n)),n.push(s)}),t.map(s=>new x(s))}static join(t){return new x(t.flatMap(({Δx:n,Δy:s,shape:e})=>e.translate(n,s).commands))}convertToCubics(){return new x(this.commands.map(t=>t.toCubic()))}translate(t,n){return new x(this.commands.map(s=>s.translate(t,n)))}static fixAngleRounding(t){return t+400-400}static toDegrees(t){return Math.round(t*h.degreesPerRadian*100)/100}dump(){const t=this.commands.map((n,s)=>{const{x0:e,y0:i,x:o,y:r,incomingAngle:c,outgoingAngle:g,command:m}=n,l=document.createElementNS("http://www.w3.org/2000/svg","path");l.setAttribute("d",new x([n]).rawPath);const a=l.getTotalLength(),f=this.commands[s-1],p=x.needAnM(f,n)?{}:{difference:x.toDegrees(h.angleBetween(f.outgoingAngle,c))};return{x0:e,y0:i,x:o,y:r,incomingAngle:x.toDegrees(c),outgoingAngle:x.toDegrees(g),length:a,c:m,...p}});console.table(t),console.log(this.rawPath),console.log(JSON.stringify(this))}}function U(w,t){if(h.assertFinite(w.x0,w.y0,w.angle,t.x0,t.y0,t.angle),isNaN(w.angle)||isNaN(t.angle)||w.angle==t.angle)return;const n=Math.tan(w.angle),s=Math.tan(t.angle),e=Math.abs(n)*100>Number.MAX_SAFE_INTEGER,i=Math.abs(s)*100>Number.MAX_SAFE_INTEGER;if(e&&i)return;const o=Math.atan2(t.y0-w.y0,t.x0-w.x0),r=h.angleBetween(w.angle,o),c=h.angleBetween(t.angle,o);if(r==0||Math.abs(c)==Math.PI){if(Math.abs(r)==Math.PI||c==0)return;const l=(w.x0+t.x0)/2,a=(w.y0+t.y0)/2;return{x:l,y:a}}const g=Math.sign(r),m=Math.sign(c);if(!(g!=m||g==0)&&!(Math.abs(c)<=Math.abs(r)+h.radiansPerDegree))if(e||i){const l=e?w.x0:t.x0,a=e?{...t,slope:s}:{...w,slope:n},f=a.slope*(l-a.x0)+a.y0;return{x:l,y:f}}else{const l=(t.y0-s*t.x0-w.y0+n*w.x0)/(n-s),a=n*(l-w.x0)+w.y0;return{x:l,y:a}}}export{M as L,x as P,E as Q,H as a,X as b};
