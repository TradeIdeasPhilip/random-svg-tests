import { count, parseFloatX, zip } from "phil-lib/misc";
import { assertFinite, lerp } from "./utility";

/**
 * This class represents a _continuous_ segment of a path.
 * It always starts with an M command.
 * It contains other commands, but no more M's.
 *
 * `PathSegment` objects are read only, so they can easily
 * be shared and reused.  Operations like H() and V() will
 * create a new `PathSegment` object rather than modifying
 * the existing object.
 */
export abstract class PathSegment {
  protected constructor(
    public readonly segmentStartX: number,
    public readonly segmentStartY: number,
    public readonly endX: number,
    public readonly endY: number
  ) {
    assertFinite(segmentStartX, segmentStartY, endX, endY);
  }

  /**
   *
   * @returns A PathSegment containing only the last command from `this`, with a new M command so this can be be used without the rest of the PathSegment.
   * `remaining` and `last` together will display the same as just `this`.
   */
  popCommand(): {
    remaining: PathSegment | undefined;
    last: PathSegment;
  } {
    // By default assume there is nothing else to break up.
    // Return what's left as the last element, and undefined to say that nothing else is remaining.
    return { remaining: undefined, last: this };
  }

  /**
   * This property refers to this individual command.
   */
  protected abstract get asString(): string;
  abstract translate(Δx: number, Δy: number): PathSegment;
  abstract toCubic(): PathSegment;
  abstract [Symbol.iterator](): Iterator<PathSegment>;

  /**
   * This property refers to the entire path segment.
   */
  get rawPath() {
    return [...this].map((segment) => segment.asString).join(" ");
  }

  /**
   * Convert a list of strings into a list of `PathSegments` objects.
   *
   * This function is aimed at the output of the rough.js library.
   * It does not support all legal commands.
   * @param strings These are the inputs.
   * @returns The path segments generated by the strings.
   * @throws Any problem interpreting the input will cause this method to throw an `Error`.
   * It's ugly.
   * It's aimed at someone in the debugger, not an end user.
   */
  static fromStrings(strings: readonly string[]): PathSegment[] {
    let s = strings.join(" ");
    const allSegments: PathSegment[] = [];
    let current: PathSegment | undefined;
    while (true) {
      // Remove leading whitespace.
      s = s.replace(/^ */, "");
      if (s == "") {
        break;
      }
      let result = mCommand.exec(s);
      if (result) {
        const x = parseFloatX(result[1]);
        const y = parseFloatX(result[2]);
        if (x === undefined || y === undefined) {
          console.error(result, x, y, this);
          throw new Error("wtf");
        }
        if (current) {
          allSegments.push(current);
        }
        current = this.M(x, y);
        s = result[3];
        continue;
      }
      if (current) {
        result = qCommand.exec(s);
        if (result) {
          const x1 = parseFloatX(result[1]);
          const y1 = parseFloatX(result[2]);
          const x2 = parseFloatX(result[3]);
          const y2 = parseFloatX(result[4]);
          if (
            x1 === undefined ||
            y1 === undefined ||
            x2 === undefined ||
            y2 === undefined
          ) {
            console.error(result, x1, y1, x2, y2, this);
            throw new Error("wtf");
          }
          current = current.Q(x1, y1, x2, y2);
          s = result[5];
          continue;
        }
        result = cCommand.exec(s);
        if (result) {
          const x1 = parseFloatX(result[1]);
          const y1 = parseFloatX(result[2]);
          const x2 = parseFloatX(result[3]);
          const y2 = parseFloatX(result[4]);
          const x3 = parseFloatX(result[5]);
          const y3 = parseFloatX(result[6]);
          if (
            x1 === undefined ||
            y1 === undefined ||
            x2 === undefined ||
            y2 === undefined ||
            x3 === undefined ||
            y3 === undefined
          ) {
            console.error(result, x1, y1, x2, y2, x3, y3, this);
            throw new Error("wtf");
          }
          current = current.C(x1, y1, x2, y2, x3, y3);
          s = result[7];
          continue;
        }
      }
      console.error(s);
      throw new Error("wtf");
    }
    if (current) {
      allSegments.push(current);
    }
    return allSegments;
  }
  /**
   * Create a new `PathSegment`.
   * Note that all path segments start with an M command.
   * @param x Begin the segment here.
   * @param y Begin the segment here.
   * @returns A new segment containing a single M command.
   */
  static M(x: number, y: number): PathSegment {
    return new MCommand(x, y);
  }
  /**
   * Non destructively add an H command to this `PathSegment`.
   * @param x The argument for the H command.
   * @returns A new PathSegment ending with this command.
   */
  H(x: number): PathSegment {
    return new HCommand(this, x);
  }
  V(y: number): PathSegment {
    return new VCommand(this, y);
  }
  L(x: number, y: number): PathSegment {
    return new LCommand(this, x, y);
  }
  Q(x1: number, y1: number, x2: number, y2: number): PathSegment {
    return new QCommand(this, x1, y1, x2, y2);
  }
  /**
   * This adds a new Q command to the shape.
   * The caller explicitly supplies the second control point.
   * This automatically computes the first control point.
   * This assumes the incoming angle is horizontal and the outgoing angle is vertical.
   * @param x The x for both control points.
   * @param y The y for the final control point.
   */
  Q_HV(x: number, y: number) {
    return this.Q(x, this.endY, x, y);
  }
  /**
   * This adds a new Q command to the shape.
   * The caller explicitly supplies the second control point.
   * This automatically computes the first control point.
   * This assumes the incoming angle is vertical and the outgoing angle is horizontal.
   * @param x The x for the final control point.
   * @param y The y for both control points.
   */
  Q_VH(x: number, y: number) {
    return this.Q(this.endX, y, x, y);
  }
  C(
    x1: number,
    y1: number,
    x2: number,
    y2: number,
    x3: number,
    y3: number
  ): PathSegment {
    return new CCommand(this, x1, y1, x2, y2, x3, y3);
  }
}

class MCommand extends PathSegment {
  override *[Symbol.iterator](): Iterator<PathSegment> {
    yield this;
  }
  override translate(Δx: number, Δy: number): PathSegment {
    return new MCommand(this.endX + Δx, this.endY + Δy);
  }
  override toCubic(): PathSegment {
    return this;
  }
  readonly asString: string;
  constructor(x: number, y: number) {
    super(x, y, x, y);
    this.asString = `M ${x},${y}`;
  }
}

abstract class ContinuingCommand extends PathSegment {
  constructor(
    protected readonly previous: PathSegment,
    endX: number,
    endY: number
  ) {
    super(previous.segmentStartX, previous.segmentStartY, endX, endY);
  }
  override popCommand(): {
    remaining: PathSegment | undefined;
    last: PathSegment;
  } {
    const remaining = this.previous;
    if (!(remaining instanceof ContinuingCommand)) {
      return super.popCommand();
    }
    const last = this.duplicateCommand(
      PathSegment.M(this.segmentStartX, this.segmentStartY)
    );
    return { remaining, last };
  }
  /**
   * Copy a command as is to the end of an existing PathSegment.
   * This is typically used when changing only one command in a PathSegment.
   * @param newPrevious The base to build on top of.
   */
  protected abstract duplicateCommand(
    newPrevious: PathSegment
  ): ContinuingCommand;
  override *[Symbol.iterator](): Iterator<PathSegment> {
    yield* this.previous;
    yield this;
  }
  abstract override get asString(): string;
  abstract override translate(Δx: number, Δy: number): PathSegment;
  abstract override toCubic(): PathSegment;
  protected get commandStartX() {
    return this.previous.endX;
  }
  protected get commandStartY() {
    return this.previous.endY;
  }
}

class HCommand extends ContinuingCommand {
  protected override duplicateCommand(newPrevious: PathSegment) {
    return new HCommand(newPrevious, this.endX);
  }
  override translate(Δx: number, Δy: number): PathSegment {
    return new HCommand(this.previous.translate(Δx, Δy), this.endX + Δx);
  }
  override toCubic(): PathSegment {
    return new CCommand(
      this.previous.toCubic(),
      lerp(this.commandStartX, this.endX, 1 / 3),
      this.commandStartY,
      lerp(this.commandStartX, this.endX, 2 / 3),
      this.commandStartY,
      this.endX,
      this.commandStartY
    );
  }
  readonly asString: string;
  constructor(previous: PathSegment, x: number) {
    super(previous, x, previous.endY);
    this.asString = `H ${x}`;
  }
}

class VCommand extends ContinuingCommand {
  protected override duplicateCommand(newPrevious: PathSegment) {
    return new VCommand(newPrevious, this.endY);
  }
  override translate(Δx: number, Δy: number): PathSegment {
    return new VCommand(this.previous.translate(Δx, Δy), this.endY + Δy);
  }
  override toCubic(): PathSegment {
    return new CCommand(
      this.previous.toCubic(),
      this.commandStartX,
      lerp(this.commandStartY, this.endY, 1 / 3),
      this.commandStartX,
      lerp(this.commandStartY, this.endY, 2 / 3),
      this.commandStartX,
      this.endY
    );
  }
  readonly asString: string;
  constructor(previous: PathSegment, y: number) {
    super(previous, previous.endX, y);
    this.asString = `V ${y}`;
  }
}

class LCommand extends ContinuingCommand {
  protected override duplicateCommand(newPrevious: PathSegment) {
    return new LCommand(newPrevious, this.endX, this.endY);
  }
  override translate(Δx: number, Δy: number): PathSegment {
    return new LCommand(
      this.previous.translate(Δx, Δy),
      this.endX + Δx,
      this.endY + Δy
    );
  }
  override toCubic(): PathSegment {
    return new CCommand(
      this.previous.toCubic(),
      lerp(this.commandStartX, this.endX, 1 / 3),
      lerp(this.commandStartY, this.endY, 1 / 3),
      lerp(this.commandStartX, this.endX, 2 / 3),
      lerp(this.commandStartY, this.endY, 2 / 3),
      this.endX,
      this.endY
    );
  }
  readonly asString: string;
  constructor(previous: PathSegment, x: number, y: number) {
    super(previous, x, y);
    this.asString = `L ${x},${y}`;
  }
}

class QCommand extends ContinuingCommand {
  protected override duplicateCommand(newPrevious: PathSegment) {
    return new QCommand(newPrevious, this.x1, this.y1, this.endX, this.endY);
  }
  override translate(Δx: number, Δy: number): PathSegment {
    return new QCommand(
      this.previous.translate(Δx, Δy),
      this.x1 + Δx,
      this.y1 + Δy,
      this.endX + Δx,
      this.endY + Δy
    );
  }
  override toCubic(): PathSegment {
    // https://fontforge.org/docs/techref/bezier.html#converting-truetype-to-postscript
    return new CCommand(
      this.previous.toCubic(),
      lerp(this.commandStartX, this.x1, 2 / 3),
      lerp(this.commandStartY, this.y1, 2 / 3),
      lerp(this.endX, this.x1, 2 / 3),
      lerp(this.endY, this.y1, 2 / 3),
      this.endX,
      this.endY
    );
  }
  readonly asString: string;
  constructor(
    previous: PathSegment,
    public readonly x1: number,
    public readonly y1: number,
    x2: number,
    y2: number
  ) {
    assertFinite(x1, y1);
    super(previous, x2, y2);
    this.asString = `Q ${x1},${y1} ${x2},${y2}`;
  }
}

class CCommand extends ContinuingCommand {
  /**
   * Break one or more commands into a smaller pieces.  The result will
   * look the same, but the extra pieces can help some special effects.
   *
   * This is different from PathSegment.popCommand().  This function breaks
   * one or more commands into multiple commands.  This function returns
   * a single PathSegment with more commands than the original.
   *
   * PathSegment.popCommand() breaks a PathSegment into two PathSegment
   * objects.  That creates a new M command but leaves all of the drawing
   * commands alone.
   * @param numberOfPieces Turn this command into how many commands?
   * 1 would be a no-op and will (probably) make a copy of `this`.
   *
   * If you provide multiple values, the first will apply to `this`
   * command directly, the second will apply to `this.previous`, the
   * third to `this.previous.previous`, etc.
   * @returns A new `CCommand` object that looks the same as the original
   * but has more commands in it.
   * @throws If one of the `previous` items does not support this
   * function, but it needs to, this function will throw an error.
   */
  splitIndividualCommands(...numberOfPieces: number[]) {
    // See https://pomax.github.io/bezierinfo/#splitting for the algorithm for splitting a single command.
    const current = numberOfPieces.shift();
    throw new Error("TODO");
    if (!current) {
      return;
    }
  }
  protected override duplicateCommand(newPrevious: PathSegment) {
    return new CCommand(
      newPrevious,
      this.x1,
      this.y1,
      this.x2,
      this.y2,
      this.x3,
      this.y3
    );
  }
  override translate(Δx: number, Δy: number): PathSegment {
    return new CCommand(
      this.previous.translate(Δx, Δy),
      this.x1 + Δx,
      this.y1 + Δy,
      this.x2 + Δx,
      this.y2 + Δy,
      this.x3 + Δx,
      this.y3 + Δy
    );
  }
  override toCubic(): PathSegment {
    const upstream = this.previous.toCubic();
    if (upstream == this.previous) {
      return this;
    } else {
      return new CCommand(
        upstream,
        this.x1,
        this.y1,
        this.x2,
        this.y2,
        this.x3,
        this.y3
      );
    }
  }
  readonly asString: string;
  constructor(
    previous: PathSegment,
    public readonly x1: number,
    public readonly y1: number,
    public readonly x2: number,
    public readonly y2: number,
    public readonly x3: number,
    public readonly y3: number
  ) {
    assertFinite(x1, x2, y1, y2);
    super(previous, x3, y3);
    this.asString = `C ${x1},${y1} ${x2},${y2} ${x3},${y3}`;
  }
}

const afterCommand = " *";
const number = "(-?[0-9]+.?[0-9]*)";
const between = " *[, ] *";
const mCommand = new RegExp(
  `^M${afterCommand}${number}${between}${number}(.*)$`
);
const qCommand = new RegExp(
  `^Q${afterCommand}${number}${between}${number}${between}${number}${between}${number}(.*)$`
);
const cCommand = new RegExp(
  `^C${afterCommand}${number}${between}${number}${between}${number}${between}${number}${between}${number}${between}${number}(.*)$`
);

/**
 * This is a way to manipulate a path shape.
 * I.e. to create a string like "path('M 1,2 L 3,5')".
 */
export class PathShape {
  matchForMorph(other: PathShape) {
    const thisSegments = [...this.segments];
    const otherSegments = [...other.segments];
    // Consider getting rid of segments with nothing but an M.
    if (thisSegments.length != otherSegments.length) {
      // The number of M commands don't match.
      // Add additional M commands to make them match.
      // Because I'm using rounded corners and rounded end caps, this will not change the path's appearance.
      const { shorter, longer } =
        thisSegments.length < otherSegments.length
          ? { shorter: thisSegments, longer: otherSegments }
          : { shorter: otherSegments, longer: thisSegments };
      if (shorter.length == 0) {
        // One list of segments was completely empty and the other was not.
        throw new Error("can't morph something into nothing");
      }
      let remainingToAdd = longer.length - shorter.length;
      const rightOfShorter: PathSegment[] = [];
      while (remainingToAdd > 0) {
        const old = shorter.pop();
        if (!old) {
          // Need to break existing commands into multiple commands then spit each into its own PathSegment
          throw new Error("TODO");
        }
        const { remaining, last } = old.popCommand();
        rightOfShorter.unshift(last);
        if (remaining) {
          shorter.push(remaining);
          remainingToAdd--;
        }
      }
      shorter.push(...rightOfShorter);
    }
    if (thisSegments.length != otherSegments.length) {
      throw new Error("wtf");
    }
    for (const [thisSegment, otherSegment, index] of zip(
      thisSegments,
      otherSegments,
      count()
    )) {
      const thisCommands = [...thisSegment];
      const otherCommands = [...otherSegment];
      if (thisCommands.length != otherCommands.length) {
        const [shorter, longer] =
          thisCommands.length < otherCommands.length
            ? [thisCommands, otherCommands]
            : [otherCommands, thisCommands];
        const needToAdd = longer.length - shorter.length;
        const toSplit = shorter.pop();
      }
    }
    //TODO!!!  Implement this next!
    /* If both commands are the same type, copy them as is.
     * Call toCubic on both commands.
     * What if one is longer than the other???!
     */
    return { thisSegments, otherSegments };
  }
  readonly segments: readonly PathSegment[];
  get endX() {
    // Defined HERE (https://www.youtube.com/watch?v=4yVOFGLoeIE for details)
    return this.segments.at(-1)?.endX;
  }
  get endY() {
    return this.segments.at(-1)?.endY;
  }
  get startX() {
    return this.segments.at(0)?.segmentStartX;
  }
  get startY() {
    return this.segments.at(0)?.segmentStartY;
  }
  /**
   *
   * @param strings Each is a path string, e.g "M1,2 L3,4".
   * @returns A new PathShape based on the path strings.
   */
  static fromStrings(strings: string[]) {
    const segments = PathSegment.fromStrings(strings);
    const result = new this(segments);
    return result;
  }
  constructor(segments: readonly PathSegment[]) {
    this.segments = [...segments];
  }

  static cssifyPath(rawPath: string) {
    return `path('${rawPath}')`;
  }
  get cssPath() {
    return PathShape.cssifyPath(this.rawPath);
  }
  makeElement() {
    const pathElement = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "path"
    );
    const cssPath = this.cssPath;
    pathElement.style.d = cssPath;
    if (pathElement.style.d == "") {
      console.error(cssPath, pathElement);
      throw new Error("wtf");
    }
    return pathElement;
  }

  get rawPath() {
    return this.segments.map((segment) => segment.rawPath).join(" ");
  }
  /**
   * Like css path, but broken each time the pen is lifted.
   * Each string in the result is a valid path where all of the parts are connected.
   */
  get cssPaths(): string[] {
    return this.splitOnMove().map((shape) => shape.cssPath);
  }
  get rawPaths(): string[] {
    return this.splitOnMove().map((shape) => shape.rawPath);
  }
  /**
   * Split this PathShape into smaller PathShapes.
   * Break it on the move (M) commands, so each of the
   * new shapes can be use independently.
   *
   * Undo with `PathShape.join()`.
   */
  splitOnMove() {
    return [...this.segments].map(
      (segment) =>
        // Asserted HERE (https://www.youtube.com/watch?v=4yVOFGLoeIE for details)
        new PathShape([segment]) as PathShape & {
          readonly startX: number;
          readonly startY: number;
          readonly endX: number;
          readonly endY: number;
        }
    );
  }
  /**
   * @param shapes The shapes to merge
   * @returns A single shape that includes all of the input shapes
   */
  static join(
    pieces: { Δx: number; Δy: number; shape: PathShape }[]
  ): PathShape {
    return new PathShape(
      pieces.flatMap(({ Δx, Δy, shape }) => shape.translate(Δx, Δy).segments)
    );
  }
  convertToCubics(): PathShape {
    return new PathShape(
      this.segments.map((pathSegment) => pathSegment.toCubic())
    );
  }
  translate(Δx: number, Δy: number): PathShape {
    return new PathShape(
      this.segments.map((pathSegment) => pathSegment.translate(Δx, Δy))
    );
  }
}
